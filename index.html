<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Drone Sightings — Europe (Air, Sea & Infrastructure)</title>
  <!-- Force deployment update 2025-09-25 -->
  <!-- Second deployment fix 19:30 -->
  <!-- Asset layer fix 19:53 -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="anonymous" />
  <style>
    :root {
      --bg: #0a0d14;
      --panel: #13161f;
      --surface: #1a1f2b;
      --card: #242936;
      --muted: #9ca3af;
      --text: #f8fafc;
      --border: #334155;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --purple: #8b5cf6;

      /* Asset colors */
      --air: #ef4444;
      --harbour: #3b82f6;
      --energy: #f97316;
      --rail: #22c55e;
      --border-crossing: #eab308;
      --military: #8b5cf6;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Mobile-first responsive layout */
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      height: 100dvh; /* Dynamic viewport height for mobile */
    }

    /* Header - mobile optimized */
    header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: linear-gradient(135deg, #0f1419 0%, #1a202c 100%);
      border-bottom: 1px solid var(--border);
      min-height: 60px;
      flex-shrink: 0;
      overflow-x: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    header::-webkit-scrollbar { display: none; }

    header h1 {
      font-size: 14px;
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.02em;
      white-space: nowrap;
      background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .badge {
      padding: 4px 10px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text);
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .badge.live {
      background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
      color: white;
      border-color: var(--success);
      animation: pulse-glow 2s ease-in-out infinite;
    }

    /* Main content area */
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Mobile: Stack layout */
    .panels-container {
      display: none; /* Hidden on mobile by default */
      flex-direction: column;
      width: 100%;
      background: var(--panel);
      border-right: 1px solid var(--border);
      overflow-y: auto;
    }

    #map-container {
      flex: 1;
      position: relative;
      background: var(--surface);
    }

    #map {
      width: 100%;
      height: 100%;
      border-radius: 0;
    }

    /* Mobile panels toggle */
    .mobile-toggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mobile-toggle:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
    }

    /* Panel sections */
    .panel {
      padding: 16px;
      max-height: 50vh;
      overflow-y: auto;
    }

    h2 {
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.1em;
      margin: 0 0 12px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section {
      margin-bottom: 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    /* Modern chip design */
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 25px;
      background: var(--surface);
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .chip:hover {
      background: var(--card);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .chip.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    /* Form elements */
    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--surface);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
    }

    select, input[type="text"] {
      width: 100%;
      padding: 12px 16px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      outline: none;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    select:focus, input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    /* Stats and legends */
    .legend {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 12px;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      border: 1px solid rgba(255,255,255,.2);
      margin-right: 6px;
    }

    .statbar {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
    }

    .stat {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px 12px;
      text-align: center;
      transition: all 0.2s ease;
    }

    .stat:hover {
      background: var(--surface);
      border-color: var(--accent);
    }

    .stat .k {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 4px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--purple) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .stat .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-weight: 600;
    }

    /* Modern incident cards */
    .incident {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 12px;
      background: var(--card);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .incident::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: linear-gradient(to bottom, var(--accent), var(--purple));
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .incident:hover {
      border-color: var(--accent);
      background: var(--surface);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.15);
    }

    .incident:hover::before {
      opacity: 1;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    /* Enhanced responsive breakpoints */
    @media (min-width: 768px) {
      #app {
        display: grid;
        grid-template-columns: 320px 1fr 360px;
        grid-template-rows: 60px 1fr;
      }

      header {
        grid-column: 1 / 4;
        overflow-x: visible;
      }

      .main-container {
        grid-column: 1 / 4;
        grid-row: 2;
        display: grid;
        grid-template-columns: 320px 1fr 360px;
      }

      .panels-container {
        display: flex;
        flex-direction: column;
        width: auto;
      }

      .mobile-toggle {
        display: none;
      }

      #map-container {
        grid-column: 2;
      }

      .panel {
        padding: 16px;
        max-height: none;
        overflow-y: auto;
      }
    }

    @media (min-width: 1200px) {
      #app {
        grid-template-columns: 380px 1fr 400px;
      }

      .main-container {
        grid-template-columns: 380px 1fr 400px;
      }
    }

    /* Mobile panel overlay */
    @media (max-width: 767px) {
      .panels-container.mobile-open {
        display: flex;
        position: fixed;
        top: 60px;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 999;
        background: var(--panel);
        animation: slideUp 0.3s ease-out;
      }

      .panels-container .panel:first-child {
        border-bottom: 1px solid var(--border);
      }
    }

    /* Animations */
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 5px rgba(16, 185, 129, 0.5); }
      50% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.8); }
    }

    @keyframes slideUp {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    .legend { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; font-size: 12px; }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; border: 1px solid rgba(0,0,0,.4); }
    .sev { display: inline-block; width: 10px; height: 10px; border-radius: 2px; margin-right: 4px; }
    .sev.s1 { background: var(--severity-1); }
    .sev.s2 { background: var(--severity-2); }
    .sev.s3 { background: var(--severity-3); }
    .sev.s4 { background: var(--severity-4); }
    .sev.s5 { background: var(--severity-5); }
    .statbar { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .stat { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 10px; text-align: center; }
    .stat .k { font-size: 18px; font-weight: 700; }
    .incident { border: 1px solid var(--border); border-radius: 12px; padding: 10px; margin-bottom: 10px; background: var(--surface); cursor: pointer; transition: border .2s ease; }
    .incident:hover { border-color: #3a4162; }
    .muted { color: var(--muted); font-size: 12px; }
    .leaflet-control-attribution { background: rgba(0,0,0,.45); color: #dfe4ff; border-radius: 8px; padding: 2px 6px; }
    .leaflet-popup-content-wrapper { background: var(--surface); color: var(--text); }
    .leaflet-popup-tip { background: var(--surface); }
    .no-data-overlay {
      background: var(--surface) !important;
      color: var(--text) !important;
      border: 2px solid var(--border) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5) !important;
    }
    .risk-tooltip {
      background: var(--surface) !important;
      color: var(--text) !important;
      border: 1px solid var(--border) !important;
      font-size: 12px !important;
    }

    /* Live Activity Pulse Animations */
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.15); }
      100% { opacity: 1; transform: scale(1); }
    }

    @keyframes pulse-ring {
      0% { opacity: 0.8; transform: scale(1); }
      100% { opacity: 0; transform: scale(2.5); }
    }

    .live-marker {
      animation: pulse 2s ease-in-out infinite;
    }

    .live-marker::before {
      content: '';
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      border: 2px solid var(--severity-4);
      border-radius: 50%;
      animation: pulse-ring 3s ease-out infinite;
      pointer-events: none;
    }

    .activity-indicator {
      position: fixed;
      top: 68px;
      right: 20px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 16px;
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
      z-index: 1000;
      display: none;
      align-items: center;
      gap: 8px;
      animation: slideInRight 0.3s ease-out;
    }

    .activity-indicator.visible {
      display: flex;
    }

    .activity-pulse {
      width: 8px;
      height: 8px;
      background: var(--severity-4);
      border-radius: 50%;
      animation: pulse 1.5s ease-in-out infinite;
    }

    /* Breaking News Alert */
    .breaking-news-alert {
      position: fixed;
      top: 68px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, var(--severity-4), #dc2626);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
      color: white;
      font-weight: 600;
      z-index: 2000;
      display: none;
      min-width: 400px;
      max-width: 600px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      animation: breakingSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .breaking-news-alert.visible {
      display: block;
    }

    .breaking-news-content {
      padding: 16px 20px;
    }

    .breaking-news-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }

    .breaking-badge {
      background: rgba(255, 255, 255, 0.9);
      color: var(--severity-4);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 800;
      letter-spacing: 0.5px;
      animation: pulse 2s ease-in-out infinite;
    }

    .breaking-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      margin-left: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }

    .breaking-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .breaking-details {
      font-size: 14px;
      font-weight: 500;
      opacity: 0.9;
      line-height: 1.4;
    }

    @keyframes breakingSlideIn {
      0% {
        transform: translate(-50%, -100%);
        opacity: 0;
      }
      70% {
        transform: translate(-50%, 10px);
      }
      100% {
        transform: translate(-50%, 0);
        opacity: 1;
      }
    }

    /* Activity Timeline */
    .activity-timeline {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--surface);
    }

    .timeline-loading {
      padding: 20px;
      text-align: center;
      color: var(--muted);
      font-size: 12px;
    }

    .timeline-hour {
      border-bottom: 1px solid var(--border);
      padding: 8px 12px;
    }

    .timeline-hour:last-child {
      border-bottom: none;
    }

    .timeline-hour-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .timeline-hour-count {
      background: var(--chip);
      color: var(--text);
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
    }

    .timeline-incidents {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .timeline-incident {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 6px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s ease;
      font-size: 11px;
    }

    .timeline-incident:hover {
      background: var(--chip-active);
    }

    .timeline-incident-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .timeline-incident-info {
      flex: 1;
      min-width: 0;
    }

    .timeline-incident-name {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .timeline-incident-time {
      color: var(--muted);
      font-size: 10px;
    }

    .timeline-empty {
      padding: 12px;
      text-align: center;
      color: var(--muted);
      font-size: 11px;
      font-style: italic;
    }
    @keyframes slideInRight {
      from { transform: translateX(100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    @keyframes slideOutRight {
      from { transform: translateX(0); opacity: 1; }
      to { transform: translateX(100%); opacity: 0; }
    }
    @media (max-width: 1120px) {
      #app { grid-template-columns: 1fr; grid-template-rows: 56px 260px 1fr 320px; }
      #left { grid-row: 2; }
      #map { grid-row: 3; }
      #right { grid-row: 4; }
      header { grid-column: 1; }
    }
  </style>
</head>
<body>
  <div id="app" role="application" aria-label="Drone Sightings interactive map">
    <header>
      <h1>🛡️ DroneWatch Europe</h1>
      <span class="badge live" style="background: linear-gradient(135deg, var(--success) 0%, #059669 100%); color: white;">🔴 LIVE</span>
      <span class="badge">🛰️ Real-time</span>
      <span class="badge" id="badge-refresh">⚡ Auto-sync</span>
      <span class="badge" id="badge-generated">📅 Updated: —</span>
      <span class="badge" id="badge-status" style="display: none; background: var(--danger); color: #fff; font-weight: 700;">⚠️ NO DATA</span>
      <button class="badge" id="btn-share" style="background: var(--accent); color: #fff; border: none; cursor: pointer; font-weight: 600;">🔗 Share</button>
    </header>

    <div class="main-container">
      <!-- Left Panel - Filters & Controls -->
      <div class="panels-container" id="panels">
        <div class="panel" id="left-panel">

    <!-- Live Activity Indicator -->
    <div id="activity-indicator" class="activity-indicator">
      <div class="activity-pulse"></div>
      <span id="activity-text">Live Activity</span>
    </div>

    <!-- Breaking News Alert -->
    <div id="breaking-news-alert" class="breaking-news-alert">
      <div class="breaking-news-content">
        <div class="breaking-news-header">
          <span class="breaking-badge">BREAKING</span>
          <span id="breaking-title">New Drone Incident</span>
          <button id="breaking-close" class="breaking-close">×</button>
        </div>
        <div id="breaking-details" class="breaking-details">
          Location and details will appear here
        </div>
      </div>
    </div>

    <aside id="left" aria-label="Filters">
      <div class="section" style="background: var(--chip); border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin-bottom: 16px;">
        <h2 style="color: var(--severity-4); margin-top: 0;">🔴 Live Monitoring</h2>
        <p style="font-size: 11px; line-height: 1.4; margin: 0; color: var(--muted);">
          Displaying <strong>real drone incidents</strong> affecting European critical infrastructure. Data sourced from news outlets, official NOTAMs, and public reports. Updated continuously.
        </p>
      </div>

      <div class="section">
        <h2>Time Window</h2>
        <div class="chips" role="group" aria-label="Quick time windows">
          <button class="chip active" data-window="7">7d</button>
          <button class="chip" data-window="30">30d</button>
          <button class="chip" data-window="90">90d</button>
          <button class="chip" data-window="365">365d</button>
        </div>
        <label for="dateRange">Filter by days</label>
        <input id="dateRange" type="range" min="1" max="365" value="7" step="1" aria-valuemin="1" aria-valuemax="365" aria-valuenow="7" />
        <div class="muted" id="dateRangeLabel">Showing last 7 days</div>
      </div>

      <div class="section">
        <h2>Asset Layers</h2>
        <div class="legend" role="group" aria-label="Asset toggles">
          <label><input type="checkbox" id="layer-airport" checked /> <span class="dot" style="background:var(--air);"></span> Airports</label>
          <label><input type="checkbox" id="layer-harbour" checked /> <span class="dot" style="background:var(--harbour);"></span> Harbours</label>
          <label><input type="checkbox" id="layer-energy" checked /> <span class="dot" style="background:var(--energy);"></span> Energy</label>
          <label><input type="checkbox" id="layer-rail" checked /> <span class="dot" style="background:var(--rail);"></span> Rail hubs</label>
          <label><input type="checkbox" id="layer-border" checked /> <span class="dot" style="background:var(--border-crossing);"></span> Border crossings</label>
          <label><input type="checkbox" id="layer-military" checked /> <span class="dot" style="background:var(--military);"></span> Military</label>
        </div>
      </div>

      <div class="section">
        <h2>Risk Visualization</h2>
        <label><input type="checkbox" id="show-risk-rings" checked /> Show risk rings around critical assets</label>
        <div class="muted" style="font-size: 11px; margin-top: 4px;">2km/5km operational zones based on asset type and threat profile</div>

        <label style="margin-top: 8px;"><input type="checkbox" id="show-threat-heatmap" /> Show regional threat heatmap</label>
        <div class="muted" style="font-size: 11px; margin-top: 4px;">Visualize incident density and severity concentrations across regions</div>
      </div>

      <div class="section">
        <h2>Navigation</h2>
        <label><input type="checkbox" id="auto-focus" checked /> Auto-focus on recent activity</label>
        <div class="muted" style="font-size: 11px; margin-top: 4px;">Automatically center map on most recent incidents when loading</div>
      </div>

      <div class="section">
        <h2>Compare Mode</h2>
        <label><input type="checkbox" id="compare-mode" /> Compare periods</label>
        <div class="muted" style="font-size: 11px; margin-top: 4px;">Show current period vs previous period for trend analysis</div>
        <div id="compare-controls" style="display: none; margin-top: 8px;">
          <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
            <span style="color: var(--severity-4); font-weight: 700;">●</span>
            <span class="muted" style="font-size: 12px;">Current</span>
            <span style="color: var(--severity-2); font-weight: 700;">●</span>
            <span class="muted" style="font-size: 12px;">Previous</span>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>Status & Evidence</h2>
        <label for="statusSelect">Status</label>
        <select id="statusSelect" multiple size="3">
          <option value="active" selected>Active</option>
          <option value="resolved" selected>Resolved</option>
          <option value="unconfirmed" selected>Unconfirmed</option>
        </select>

        <label style="margin-top:8px;" for="evidenceSelect">Evidence strength</label>
        <select id="evidenceSelect" multiple size="4">
          <option value="3" selected>3 — Official/NOTAM/NAVTEX</option>
          <option value="2" selected>2 — Multi tier-1 reports</option>
          <option value="1" selected>1 — Single credible</option>
          <option value="0" selected>0 — Unconfirmed</option>
        </select>
      </div>

      <div class="section">
        <h2>Find</h2>
        <label for="searchBox">Search assets, sources, narratives</label>
        <input id="searchBox" type="text" placeholder="e.g., CPH, Nordhavn, Reuters" />
      </div>

      <div class="section">
        <h2>Activity Timeline</h2>
        <div id="activity-timeline" class="activity-timeline">
          <div class="timeline-loading">Loading timeline...</div>
        </div>
      </div>

      <div class="section">
        <h2>Severity legend</h2>
        <div class="legend">
          <span><span class="sev s1"></span>1</span>
          <span><span class="sev s2"></span>2</span>
          <span><span class="sev s3"></span>3</span>
          <span><span class="sev s4"></span>4</span>
          <span><span class="sev s5"></span>5</span>
        </div>
      </div>

      <div class="section">
        <h2>Summary</h2>
        <div class="statbar">
          <div class="stat"><div class="k" id="stat-total">0</div><div class="muted">Incidents</div></div>
          <div class="stat"><div class="k" id="stat-air">0</div><div class="muted">Airports</div></div>
          <div class="stat"><div class="k" id="stat-har">0</div><div class="muted">Harbours</div></div>
        </div>
      </div>

      <div class="section muted" style="font-size:11px;">
        Basemap © Esri; OSM contributors. Data refreshes hourly; UI reloads automatically every 5 minutes.
      </div>
    </aside>

    <main id="map" role="region" aria-label="Incident map">
      <div id="mapOverlay" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; background: var(--surface); border: 3px solid var(--severity-4); border-radius: 16px; padding: 40px 60px; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.8);">
        <div style="font-size: 48px; font-weight: 900; color: var(--severity-4); margin-bottom: 16px; letter-spacing: 3px;">NO DATA</div>
        <div style="color: var(--muted); font-size: 16px; line-height: 1.4;">Europe-wide incident monitoring system<br/>No current incidents detected</div>
      </div>
    </main>

    <aside id="right" aria-label="Incident details">
      <div id="details">
        <h2>Incident feed</h2>
        <p class="muted" id="detailsIntro">Pins refresh every few minutes. Click a marker or list item for full provenance.</p>
        <div id="noDataMessage" style="display: none; text-align: center; padding: 60px 20px; background: var(--surface); border: 2px solid var(--border); border-radius: 12px; margin: 20px 0;">
          <div style="font-size: 32px; font-weight: 900; color: var(--text); margin-bottom: 16px; letter-spacing: 2px;">NO DATA</div>
          <div class="muted" style="line-height: 1.5; font-size: 14px;">No incidents match the current filters.<br />Try expanding the time window or enabling more status options.</div>
        </div>
        <div id="incidentList"></div>
      </div>
    </aside>

    <!-- Provenance Modal -->
    <div id="provenanceModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; overflow-y: auto;">
      <div style="background: var(--surface); margin: 40px auto; padding: 0; border-radius: 16px; max-width: 800px; border: 2px solid var(--border); box-shadow: 0 8px 32px rgba(0,0,0,0.9);">
        <div style="padding: 24px; border-bottom: 1px solid var(--border);">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="margin: 0; color: var(--text); font-size: 20px;">Incident Provenance</h2>
            <button id="closeProvenance" style="background: var(--chip); border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px; color: var(--text); cursor: pointer; font-size: 16px;">✕</button>
          </div>
        </div>
        <div id="provenanceContent" style="padding: 24px; max-height: 60vh; overflow-y: auto;"></div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin="anonymous"></script>
  <script>
    const INCIDENTS_URL = 'incidents.json';
    const REFRESH_MS = 5 * 60 * 1000;

    const assetColors = {
      airport: getComputedStyle(document.documentElement).getPropertyValue('--air') || '#ef4444',
      harbour: getComputedStyle(document.documentElement).getPropertyValue('--harbour') || '#3b82f6',
      energy: getComputedStyle(document.documentElement).getPropertyValue('--energy') || '#f97316',
      rail: getComputedStyle(document.documentElement).getPropertyValue('--rail') || '#22c55e',
      border: getComputedStyle(document.documentElement).getPropertyValue('--border-crossing') || '#eab308',
      military: getComputedStyle(document.documentElement).getPropertyValue('--military') || '#c084fc'
    };

    const map = L.map('map', {
      center: [56, 12],
      zoom: 4,
      minZoom: 3,
      worldCopyJump: true
    });

    const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Basemap © Esri — Sources: Esri, i-cubed, USDA, USGS, AeroGRID, IGN, IGP'
    }).addTo(map);
    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    });
    L.control.layers({ 'Satellite': satellite, 'Streets': streets }, null, { collapsed: true }).addTo(map);

    const clusterGroups = {
      airport: L.markerClusterGroup({ disableClusteringAtZoom: 10 }),
      harbour: L.markerClusterGroup({ disableClusteringAtZoom: 10 }),
      energy: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
      rail: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
      border: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
      military: L.markerClusterGroup({ disableClusteringAtZoom: 8 })
    };
    Object.values(clusterGroups).forEach(group => map.addLayer(group));

    // Risk rings layer group
    const riskRings = L.layerGroup().addTo(map);

    // Threat heatmap layer group
    const threatHeatmap = L.layerGroup();

    const state = {
      data: { generated_utc: null, incidents: [] },
      markers: new Map(),
      showRiskRings: true,
      showThreatHeatmap: false,
      compareMode: false,
      hasAutoFocused: false,
      autoFocusEnabled: true,
      liveIncidents: new Set(),
      activityIndicatorVisible: false
    };

    // URL state management for shareable links
    function saveStateToURL() {
      const params = new URLSearchParams();

      // Time window
      params.set('days', document.getElementById('dateRange').value);

      // Asset layers
      if (document.getElementById('layer-airport').checked) params.append('layers', 'airport');
      if (document.getElementById('layer-harbour').checked) params.append('layers', 'harbour');
      if (document.getElementById('layer-energy').checked) params.append('layers', 'energy');
      if (document.getElementById('layer-rail').checked) params.append('layers', 'rail');
      if (document.getElementById('layer-border').checked) params.append('layers', 'border');
      if (document.getElementById('layer-military').checked) params.append('layers', 'military');

      // Status filters
      const statusOptions = Array.from(document.getElementById('statusSelect').selectedOptions);
      statusOptions.forEach(opt => params.append('status', opt.value));

      // Evidence filters
      const evidenceOptions = Array.from(document.getElementById('evidenceSelect').selectedOptions);
      evidenceOptions.forEach(opt => params.append('evidence', opt.value));

      // Search term
      const searchTerm = document.getElementById('searchBox').value.trim();
      if (searchTerm) params.set('search', searchTerm);

      // Risk rings
      if (state.showRiskRings) params.set('risks', '1');

      // Compare mode
      if (state.compareMode) params.set('compare', '1');

      // Auto-focus (only save if disabled, since it's enabled by default)
      if (!state.autoFocusEnabled) params.set('noautofocus', '1');

      // Map view
      const center = map.getCenter();
      const zoom = map.getZoom();
      params.set('lat', center.lat.toFixed(4));
      params.set('lng', center.lng.toFixed(4));
      params.set('zoom', zoom);

      // Update URL without reload
      const newUrl = window.location.pathname + '?' + params.toString();
      window.history.replaceState({}, '', newUrl);
    }

    function loadStateFromURL() {
      const params = new URLSearchParams(window.location.search);

      // Time window
      if (params.has('days')) {
        const days = params.get('days');
        document.getElementById('dateRange').value = days;
        document.getElementById('dateRangeLabel').textContent = `Showing last ${days} days`;
        // Update active chip
        document.querySelectorAll('.chip[data-window]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.window === days);
        });
      }

      // Asset layers
      const layers = params.getAll('layers');
      if (layers.length > 0) {
        document.getElementById('layer-airport').checked = layers.includes('airport');
        document.getElementById('layer-harbour').checked = layers.includes('harbour');
        document.getElementById('layer-energy').checked = layers.includes('energy');
        document.getElementById('layer-rail').checked = layers.includes('rail');
        document.getElementById('layer-border').checked = layers.includes('border');
        document.getElementById('layer-military').checked = layers.includes('military');
      }

      // Status filters
      const statuses = params.getAll('status');
      if (statuses.length > 0) {
        Array.from(document.getElementById('statusSelect').options).forEach(opt => {
          opt.selected = statuses.includes(opt.value);
        });
      }

      // Evidence filters
      const evidences = params.getAll('evidence');
      if (evidences.length > 0) {
        Array.from(document.getElementById('evidenceSelect').options).forEach(opt => {
          opt.selected = evidences.includes(opt.value);
        });
      }

      // Search term
      if (params.has('search')) {
        document.getElementById('searchBox').value = params.get('search');
      }

      // Risk rings
      if (params.has('risks')) {
        state.showRiskRings = params.get('risks') === '1';
        document.getElementById('show-risk-rings').checked = state.showRiskRings;
      }

      // Compare mode
      if (params.has('compare')) {
        state.compareMode = params.get('compare') === '1';
        document.getElementById('compare-mode').checked = state.compareMode;
        document.getElementById('compare-controls').style.display = state.compareMode ? 'block' : 'none';
      }

      // Auto-focus
      if (params.has('noautofocus')) {
        state.autoFocusEnabled = false;
        document.getElementById('auto-focus').checked = false;
      }

      // Map view
      if (params.has('lat') && params.has('lng') && params.has('zoom')) {
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const zoom = parseInt(params.get('zoom'));
        map.setView([lat, lng], zoom);
      }
    }

    function sevBox(score) {
      const level = Math.min(5, Math.max(1, Number(score) || 1));
      return `<span class="sev s${level}"></span>`;
    }

    function markerIcon(color, severity, isPrevious = false) {
      const size = 10 + (Number(severity) || 1) * 2;
      const borderStyle = isPrevious ? '2px dashed rgba(15,17,25,0.85)' : '2px solid rgba(15,17,25,0.85)';
      const opacity = isPrevious ? '0.7' : '1';
      return L.divIcon({
        html: `<div style="width:${size}px;height:${size}px;border-radius:50%;background:${color.trim()};border:${borderStyle};box-shadow:0 0 0 1px rgba(0,0,0,.35);opacity:${opacity};"></div>`,
        className: '',
        iconSize: [size, size]
      });
    }

    function fmtDate(value) {
      if (!value) return '—';
      try {
        return new Date(value).toISOString().slice(0, 16).replace('T', ' ');
      } catch (err) {
        return value;
      }
    }

    function fmtDuration(minutes) {
      if (minutes == null) return '—';
      if (minutes < 60) return `${minutes} min`;
      return `${(minutes / 60).toFixed(1)} h`;
    }

    function activeDays() {
      return parseInt(document.getElementById('dateRange').value, 10) || 365;
    }

    function selectedValues(select) {
      const opts = Array.from(select.selectedOptions).map(opt => opt.value);
      return opts.length ? opts : Array.from(select.options).map(opt => opt.value);
    }

    function assetToggles() {
      return {
        airport: document.getElementById('layer-airport').checked,
        harbour: document.getElementById('layer-harbour').checked,
        energy: document.getElementById('layer-energy').checked,
        rail: document.getElementById('layer-rail').checked,
        border: document.getElementById('layer-border').checked,
        military: document.getElementById('layer-military').checked
      };
    }

    function mapAssetType(assetType) {
      // Map asset types to filter categories
      if (assetType === 'nuclear') return 'energy';
      return assetType;
    }

    function searchTerm() {
      return document.getElementById('searchBox').value.trim().toLowerCase();
    }

    function filterIncidents(period = 'current') {
      const days = activeDays();
      let cutoffStart, cutoffEnd;

      if (state.compareMode && period === 'previous') {
        // Previous period: (2 * days) ago to (days) ago
        cutoffEnd = Date.now() - days * 24 * 3600 * 1000;
        cutoffStart = Date.now() - 2 * days * 24 * 3600 * 1000;
      } else {
        // Current period: (days) ago to now
        cutoffEnd = Date.now();
        cutoffStart = Date.now() - days * 24 * 3600 * 1000;
      }

      const statuses = new Set(selectedValues(document.getElementById('statusSelect')));
      const evidences = new Set(selectedValues(document.getElementById('evidenceSelect')));
      const query = searchTerm();

      return state.data.incidents.filter(item => {
        const seenTs = Date.parse(item.first_seen_utc || item.last_update_utc || state.data.generated_utc || Date.now());

        if (!Number.isFinite(seenTs)) return false;
        if (seenTs < cutoffStart || seenTs > cutoffEnd) return false;
        if (!statuses.has(item.incident.status)) return false;
        if (!evidences.has(String(item.evidence.strength))) return false;
        if (query) {
          const haystack = [
            item.asset.name,
            item.asset.iata,
            item.asset.icao,
            item.incident.narrative,
            ...(item.evidence.sources || []).map(src => src.publisher)
          ].join(' ').toLowerCase();
          if (!haystack.includes(query)) return false;
        }
        return true;
      });
    }

    function popupHtml(incident) {
      const srcLinks = (incident.evidence.sources || []).slice(0, 2).map(src => {
        const label = src.publisher || 'source';
        return `<a href="${src.url}" target="_blank" rel="noopener">${label}</a>`;
      }).join(' · ');
      return `
        <strong>${incident.asset.name}${incident.asset.iata ? ` (${incident.asset.iata})` : ''}</strong><br />
        <b>Asset:</b> ${incident.asset.type} · ${sevBox(incident.scores.severity)} <b>Severity:</b> ${incident.scores.severity}<br />
        <b>Status:</b> ${incident.incident.status} · <b>Category:</b> ${incident.incident.category}<br />
        <b>Window:</b> ${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}<br />
        <b>Evidence:</b> ${incident.evidence.strength} · ${srcLinks || '<span class="muted">no link</span>'}<br />
        <div style="text-align: center; margin-top: 8px;">
          <button class="popup-provenance-btn" style="background: var(--focus); color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 11px;">
            📋 Full Provenance
          </button>
        </div>
      `;
    }

    function renderDetails(currentIncidents, previousIncidents = []) {
      const list = document.getElementById('incidentList');
      const intro = document.getElementById('detailsIntro');
      const noDataMessage = document.getElementById('noDataMessage');

      console.log('renderDetails called with', currentIncidents.length, 'current and', previousIncidents.length, 'previous incidents');
      list.innerHTML = '';

      const totalCurrent = currentIncidents.length;
      const totalPrevious = previousIncidents.length;

      if (!totalCurrent && !totalPrevious) {
        console.log('Showing NO DATA message');
        intro.style.display = 'none';
        noDataMessage.style.display = 'block';
        return;
      }

      intro.style.display = 'block';
      noDataMessage.style.display = 'none';

      if (state.compareMode) {
        intro.innerHTML = `Current period: <strong>${totalCurrent}</strong> incidents | Previous period: <strong>${totalPrevious}</strong> incidents`;
      } else {
        intro.textContent = 'Most recent incidents. Click to focus on the map.';
      }

      // Show current period incidents
      const currentSorted = currentIncidents.sort((a, b) => Date.parse(b.first_seen_utc) - Date.parse(a.first_seen_utc));
      currentSorted.slice(0, state.compareMode ? 6 : 12).forEach(incident => {
        const card = document.createElement('div');
        card.className = 'incident';
        card.innerHTML = `
          <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
            <strong>${incident.asset.name}</strong>
            <div style="display: flex; gap: 8px; align-items: center;">
              <span class="muted">${incident.asset.type}</span>
              <button class="provenance-btn" style="background: var(--chip); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; color: var(--focus); cursor: pointer; font-size: 11px;">📋 Info</button>
            </div>
          </div>
          <div class="muted" style="margin:6px 0">${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}</div>
          <div>Category: <b>${incident.incident.category}</b> • Status: <b>${incident.incident.status}</b> • Evidence: <b>${incident.evidence.strength}</b> • Severity: <b>${incident.scores.severity}</b></div>
          <div class="muted" style="margin:6px 0">${incident.incident.narrative || ''}</div>
          <div>Sources: ${(incident.evidence.sources || []).map(src => `<a href="${src.url}" target="_blank" rel="noopener">${src.publisher || 'source'}</a>`).join(' · ') || '<span class="muted">—</span>'}</div>
        `;
        card.addEventListener('click', (e) => {
          if (e.target.classList.contains('provenance-btn')) {
            e.stopPropagation();
            showProvenance(incident);
          } else {
            focusIncident(incident);
          }
        });
        list.appendChild(card);
      });

      // Show previous period incidents if in compare mode
      if (state.compareMode && previousIncidents.length > 0) {
        const separator = document.createElement('div');
        separator.style.cssText = 'margin: 16px 0; padding: 8px 0; border-top: 1px solid var(--border); color: var(--severity-2); font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em;';
        separator.textContent = 'Previous Period';
        list.appendChild(separator);

        const previousSorted = previousIncidents.sort((a, b) => Date.parse(b.first_seen_utc) - Date.parse(a.first_seen_utc));
        previousSorted.slice(0, 6).forEach(incident => {
          const card = document.createElement('div');
          card.className = 'incident';
          card.style.borderColor = 'var(--severity-2)';
          card.style.opacity = '0.8';
          card.innerHTML = `
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
              <strong>${incident.asset.name}</strong>
              <div style="display: flex; gap: 8px; align-items: center;">
                <span class="muted">${incident.asset.type}</span>
                <button class="provenance-btn" style="background: var(--chip); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; color: var(--focus); cursor: pointer; font-size: 11px;">📋 Info</button>
              </div>
            </div>
            <div class="muted" style="margin:6px 0">${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}</div>
            <div>Category: <b>${incident.incident.category}</b> • Status: <b>${incident.incident.status}</b> • Evidence: <b>${incident.evidence.strength}</b> • Severity: <b>${incident.scores.severity}</b></div>
            <div class="muted" style="margin:6px 0">${incident.incident.narrative || ''}</div>
            <div>Sources: ${(incident.evidence.sources || []).map(src => `<a href="${src.url}" target="_blank" rel="noopener">${src.publisher || 'source'}</a>`).join(' · ') || '<span class="muted">—</span>'}</div>
          `;
          card.addEventListener('click', (e) => {
            if (e.target.classList.contains('provenance-btn')) {
              e.stopPropagation();
              showProvenance(incident);
            } else {
              focusIncident(incident);
            }
          });
          list.appendChild(card);
        });
      }
    }

    function focusIncident(incident) {
      const marker = state.markers.get(incident.id);
      if (!marker) return;
      map.setView(marker.getLatLng(), Math.max(map.getZoom(), 7));
      marker.openPopup();
    }

    function showProvenance(incident) {
      const modal = document.getElementById('provenanceModal');
      const content = document.getElementById('provenanceContent');

      // Calculate decision factors
      const evidenceLevel = incident.evidence.strength;
      const severityScore = incident.scores.severity;
      const statusClass = incident.incident.status === 'active' ? 'severity-4' : 'muted';

      // Format sources with credibility indicators
      const sourcesList = (incident.evidence.sources || []).map((source, idx) => {
        const tier1Sources = ['Reuters', 'AP', 'BBC', 'DR Nyheder', 'NRK', 'SVT Nyheter', 'Swedavia (Official)'];
        const tier2Sources = ['TV 2 Lorry', 'The Local Sweden', 'The Local Denmark'];
        const publisherClass = tier1Sources.includes(source.publisher) ? 'severity-3' :
                              tier2Sources.includes(source.publisher) ? 'severity-2' : 'muted';
        return `
          <div style="border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin: 8px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <strong style="color: var(--${publisherClass});">${source.publisher || 'Unknown Source'}</strong>
              <span class="muted" style="font-size: 11px;">${source.lang?.toUpperCase() || 'EN'}</span>
            </div>
            <div class="muted" style="font-size: 12px; margin-bottom: 8px;">
              First seen: ${fmtDate(source.first_seen)}
            </div>
            <a href="${source.url}" target="_blank" rel="noopener" style="color: var(--focus); text-decoration: none; font-size: 12px;">
              View source →
            </a>
          </div>
        `;
      }).join('');

      // Decision logic explanation
      const decisionFactors = [];
      if (evidenceLevel >= 3) decisionFactors.push('✓ Official/NOTAM confirmation');
      else if (evidenceLevel >= 2) decisionFactors.push('✓ Multiple credible sources');
      else if (evidenceLevel >= 1) decisionFactors.push('⚠ Single source verification');
      else decisionFactors.push('❌ Unverified reports');

      if (severityScore >= 4) decisionFactors.push('🔴 High operational impact');
      else if (severityScore >= 3) decisionFactors.push('🟡 Moderate impact');
      else decisionFactors.push('🟢 Low impact');

      if (incident.incident.status === 'active') decisionFactors.push('🚨 Currently active');
      if (incident.incident.response?.length) decisionFactors.push(`👮 Response: ${incident.incident.response.join(', ')}`);

      content.innerHTML = `
        <div style="margin-bottom: 24px;">
          <h3 style="margin: 0 0 8px; color: var(--text); font-size: 18px;">${incident.asset.name}</h3>
          <div style="display: flex; gap: 12px; flex-wrap: wrap; margin-bottom: 16px;">
            <span class="badge" style="background: var(--${statusClass}); color: #fff;">${incident.incident.status.toUpperCase()}</span>
            <span class="badge">Evidence: ${evidenceLevel}/3</span>
            <span class="badge">Severity: ${severityScore}/5</span>
          </div>
          <div class="muted" style="line-height: 1.4;">
            ${incident.incident.narrative || 'No additional details available.'}
          </div>
        </div>

        <div style="margin-bottom: 24px;">
          <h4 style="margin: 0 0 12px; color: var(--text);">Decision Factors</h4>
          <div style="background: var(--chip); border-radius: 8px; padding: 16px;">
            ${decisionFactors.map(factor => `<div style="margin: 4px 0; font-size: 14px;">${factor}</div>`).join('')}
          </div>
        </div>

        <div style="margin-bottom: 24px;">
          <h4 style="margin: 0 0 12px; color: var(--text);">Timeline</h4>
          <div style="font-size: 14px;">
            <div style="margin: 8px 0;"><strong>First detected:</strong> ${fmtDate(incident.first_seen_utc)}</div>
            <div style="margin: 8px 0;"><strong>Last updated:</strong> ${fmtDate(incident.last_update_utc)}</div>
            ${incident.incident.duration_min ? `<div style="margin: 8px 0;"><strong>Duration:</strong> ${fmtDuration(incident.incident.duration_min)}</div>` : ''}
          </div>
        </div>

        <div style="margin-bottom: 24px;">
          <h4 style="margin: 0 0 12px; color: var(--text);">Asset Information</h4>
          <div style="font-size: 14px;">
            <div style="margin: 8px 0;"><strong>Type:</strong> ${incident.asset.type}</div>
            ${incident.asset.iata ? `<div style="margin: 8px 0;"><strong>IATA:</strong> ${incident.asset.iata}</div>` : ''}
            ${incident.asset.icao ? `<div style="margin: 8px 0;"><strong>ICAO:</strong> ${incident.asset.icao}</div>` : ''}
            <div style="margin: 8px 0;"><strong>Coordinates:</strong> ${incident.asset.lat.toFixed(4)}, ${incident.asset.lon.toFixed(4)}</div>
            ${incident.scores.risk_radius_m ? `<div style="margin: 8px 0;"><strong>Risk radius:</strong> ${(incident.scores.risk_radius_m/1000).toFixed(1)}km</div>` : ''}
          </div>
        </div>

        <div>
          <h4 style="margin: 0 0 12px; color: var(--text);">Sources (${incident.evidence.sources?.length || 0})</h4>
          ${sourcesList || '<div class="muted">No sources available</div>'}
        </div>
      `;

      modal.style.display = 'block';
    }

    function hideProvenance() {
      document.getElementById('provenanceModal').style.display = 'none';
    }

    function renderRiskRings() {
      riskRings.clearLayers();
      if (!state.showRiskRings) return;

      const toggles = assetToggles();
      const processedAssets = new Set();

      state.data.incidents.forEach(incident => {
        const asset = incident.asset;
        const assetKey = `${asset.type}-${asset.lat}-${asset.lon}`;
        const mappedType = mapAssetType(asset.type);

        if (processedAssets.has(assetKey) || !toggles[mappedType]) return;
        processedAssets.add(assetKey);

        // Risk ring sizes based on asset type
        const ringConfig = {
          airport: { inner: 2000, outer: 5000, color: '#ef4444' },
          harbour: { inner: 1000, outer: 3000, color: '#3b82f6' },
          energy: { inner: 1500, outer: 4000, color: '#f97316' },
          rail: { inner: 800, outer: 2000, color: '#22c55e' },
          border: { inner: 500, outer: 1500, color: '#eab308' },
          military: { inner: 3000, outer: 8000, color: '#c084fc' }
        };

        const config = ringConfig[mappedType];
        if (!config) return;

        // Outer ring (restricted zone)
        const outerRing = L.circle([asset.lat, asset.lon], {
          radius: config.outer,
          fillColor: config.color,
          fillOpacity: 0.08,
          color: config.color,
          weight: 1,
          opacity: 0.3,
          dashArray: '5, 5'
        });

        // Inner ring (critical zone)
        const innerRing = L.circle([asset.lat, asset.lon], {
          radius: config.inner,
          fillColor: config.color,
          fillOpacity: 0.15,
          color: config.color,
          weight: 2,
          opacity: 0.5
        });

        outerRing.bindTooltip(`${asset.name}<br/>Restricted zone: ${(config.outer/1000)}km`, {
          permanent: false,
          className: 'risk-tooltip'
        });

        innerRing.bindTooltip(`${asset.name}<br/>Critical zone: ${(config.inner/1000)}km`, {
          permanent: false,
          className: 'risk-tooltip'
        });

        riskRings.addLayer(outerRing);
        riskRings.addLayer(innerRing);
      });
    }

    function renderThreatHeatmap() {
      threatHeatmap.clearLayers();

      if (!state.showThreatHeatmap) {
        if (map.hasLayer(threatHeatmap)) {
          map.removeLayer(threatHeatmap);
        }
        return;
      }

      if (!map.hasLayer(threatHeatmap)) {
        map.addLayer(threatHeatmap);
      }

      const filtered = filterIncidents('current');
      if (filtered.length === 0) return;

      // Create grid-based threat analysis
      const gridSize = 50000; // 50km grid cells
      const threatGrid = new Map();

      // Group incidents by geographic grid cells
      filtered.forEach(incident => {
        const lat = incident.asset.lat;
        const lon = incident.asset.lon;

        // Calculate grid cell
        const gridLat = Math.floor(lat * 1000 / (gridSize / 111320)) * (gridSize / 111320) / 1000;
        const gridLon = Math.floor(lon * 1000 / (gridSize / (111320 * Math.cos(lat * Math.PI / 180)))) * (gridSize / (111320 * Math.cos(lat * Math.PI / 180))) / 1000;
        const gridKey = `${gridLat},${gridLon}`;

        if (!threatGrid.has(gridKey)) {
          threatGrid.set(gridKey, {
            lat: gridLat,
            lon: gridLon,
            incidents: [],
            totalSeverity: 0,
            maxSeverity: 0,
            recentIncidents: 0
          });
        }

        const cell = threatGrid.get(gridKey);
        cell.incidents.push(incident);
        cell.totalSeverity += incident.scores.severity || 1;
        cell.maxSeverity = Math.max(cell.maxSeverity, incident.scores.severity || 1);

        // Count recent incidents (last 24 hours)
        const incidentTime = new Date(incident.first_seen_utc);
        const dayAgo = Date.now() - 24 * 60 * 60 * 1000;
        if (incidentTime > dayAgo) {
          cell.recentIncidents++;
        }
      });

      // Create heatmap circles for each grid cell
      threatGrid.forEach(cell => {
        const incidentCount = cell.incidents.length;
        if (incidentCount === 0) return;

        // Calculate threat level (0-1)
        const density = incidentCount / 10; // Normalize by expected max incidents per cell
        const severity = cell.totalSeverity / incidentCount; // Average severity
        const recency = cell.recentIncidents / incidentCount; // Recent activity ratio

        const threatLevel = Math.min(1, (density * 0.4 + severity / 5 * 0.4 + recency * 0.2));

        // Determine colors based on threat level
        const color = threatLevel > 0.7 ? '#dc2626' : // High threat - red
                     threatLevel > 0.5 ? '#ea580c' : // Medium-high threat - orange
                     threatLevel > 0.3 ? '#f59e0b' : // Medium threat - yellow
                     '#3b82f6'; // Low threat - blue

        const opacity = Math.max(0.1, threatLevel * 0.6);
        const radius = Math.max(15000, threatLevel * 40000); // 15-40km radius

        // Create heatmap circle
        const circle = L.circle([cell.lat, cell.lon], {
          radius: radius,
          fillColor: color,
          fillOpacity: opacity,
          color: color,
          weight: 1,
          opacity: opacity * 1.5
        });

        // Create tooltip with threat information
        const tooltipContent = `
          <div style="font-size: 12px; line-height: 1.4;">
            <strong>Threat Level: ${Math.round(threatLevel * 100)}%</strong><br>
            ${incidentCount} incident${incidentCount > 1 ? 's' : ''}<br>
            Avg Severity: ${(cell.totalSeverity / incidentCount).toFixed(1)}<br>
            ${cell.recentIncidents} recent (24h)<br>
            Max Severity: ${cell.maxSeverity}
          </div>
        `;

        circle.bindTooltip(tooltipContent, {
          permanent: false,
          className: 'risk-tooltip'
        });

        threatHeatmap.addLayer(circle);
      });

      console.log(`Rendered threat heatmap with ${threatGrid.size} grid cells`);
    }

    function render() {
      console.log('render() called, total incidents:', state.data.incidents.length);
      Object.values(clusterGroups).forEach(group => group.clearLayers());
      state.markers.clear();

      const currentFiltered = filterIncidents('current');
      const previousFiltered = state.compareMode ? filterIncidents('previous') : [];

      console.log('current period incidents:', currentFiltered.length);
      if (state.compareMode) console.log('previous period incidents:', previousFiltered.length);

      // Update status badge and map overlay
      const statusBadge = document.getElementById('badge-status');
      const mapOverlay = document.getElementById('mapOverlay');

      if (state.data.incidents.length === 0) {
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = 'NO DATA';
        mapOverlay.style.display = 'block';
      } else if (currentFiltered.length === 0 && previousFiltered.length === 0) {
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = 'NO MATCHES';
        mapOverlay.style.display = 'none';
      } else {
        statusBadge.style.display = 'none';
        mapOverlay.style.display = 'none';
      }

      const toggles = assetToggles();
      const mapMarkers = [];
      let countAir = 0;
      let countHar = 0;
      let countAirPrev = 0;
      let countHarPrev = 0;

      // Render current period incidents
      currentFiltered.forEach(incident => {
        const assetType = incident.asset.type;
        const mappedType = mapAssetType(assetType);
        if (!toggles[mappedType]) return;
        const color = assetColors[mappedType] || '#6ea8fe';
        const marker = L.marker([incident.asset.lat, incident.asset.lon], {
          icon: markerIcon(color, incident.scores.severity)
        }).bindPopup(popupHtml(incident));

        marker.incident = incident;
        marker.on('click', () => renderDetails([incident]));
        marker.on('popupopen', () => {
          const provenanceBtn = document.querySelector('.popup-provenance-btn');
          if (provenanceBtn) {
            provenanceBtn.addEventListener('click', () => showProvenance(marker.incident));
          }
        });

        state.markers.set(incident.id, marker);
        if (clusterGroups[mappedType]) {
          clusterGroups[mappedType].addLayer(marker);
        }
        mapMarkers.push(marker);

        // Add live animation if incident is live
        if (isLiveIncident(incident)) {
          // Add to live incidents set
          state.liveIncidents.add(incident.id);
          // Apply animation after marker is added to map
          setTimeout(() => addLiveMarkerAnimation(marker), 100);
        }

        if (mappedType === 'airport') countAir += 1;
        if (mappedType === 'harbour') countHar += 1;
      });

      // Render previous period incidents with different styling (if compare mode)
      if (state.compareMode) {
        previousFiltered.forEach(incident => {
          const assetType = incident.asset.type;
          const mappedType = mapAssetType(assetType);
          if (!toggles[mappedType]) return;
          const color = '#60a5fa'; // Blue for previous period
          const marker = L.marker([incident.asset.lat, incident.asset.lon], {
            icon: markerIcon(color, incident.scores.severity, true) // true = previous period
          }).bindPopup(`<div style="border-left: 3px solid #60a5fa; padding-left: 8px;"><strong>Previous Period</strong><br/>${popupHtml(incident)}</div>`);

          marker.incident = incident;
          marker.on('popupopen', () => {
            const provenanceBtn = document.querySelector('.popup-provenance-btn');
            if (provenanceBtn) {
              provenanceBtn.addEventListener('click', () => showProvenance(marker.incident));
            }
          });

          state.markers.set('prev-' + incident.id, marker);
          if (clusterGroups[mappedType]) {
            clusterGroups[mappedType].addLayer(marker);
          }
          mapMarkers.push(marker);
          if (mappedType === 'airport') countAirPrev += 1;
          if (mappedType === 'harbour') countHarPrev += 1;
        });
      }

      // Update statistics
      if (state.compareMode) {
        document.getElementById('stat-total').innerHTML = `${currentFiltered.length} <span class="muted">(vs ${previousFiltered.length})</span>`;
        document.getElementById('stat-air').innerHTML = `${countAir} <span class="muted">(vs ${countAirPrev})</span>`;
        document.getElementById('stat-har').innerHTML = `${countHar} <span class="muted">(vs ${countHarPrev})</span>`;
      } else {
        document.getElementById('stat-total').textContent = currentFiltered.length;
        document.getElementById('stat-air').textContent = countAir;
        document.getElementById('stat-har').textContent = countHar;
      }

      if (mapMarkers.length) {
        const group = L.featureGroup(mapMarkers);
        // Always fit bounds to show ALL incidents, with padding
        if (mapMarkers.length === 1) {
          // For single incident, use moderate zoom
          const incident = mapMarkers[0].incident;
          let zoomLevel = 7; // City level for single incident
          if (incident.scores.severity >= 4) zoomLevel = 8;
          if (incident.incident.status === 'active') zoomLevel = 9;
          map.setView(mapMarkers[0].getLatLng(), zoomLevel);
        } else {
          // For multiple incidents, fit bounds to show all
          map.fitBounds(group.getBounds().pad(0.2));
        }
        // Remove any existing no-data overlay
        if (map._noDataOverlay) {
          map.removeControl(map._noDataOverlay);
          map._noDataOverlay = null;
        }
      } else {
        // Show no data overlay on map if no markers to display
        if (!map._noDataOverlay) {
          map._noDataOverlay = L.control({ position: 'topright' });
          map._noDataOverlay.onAdd = function() {
            const div = L.DomUtil.create('div', 'no-data-overlay');
            div.style.cssText = 'padding: 20px 24px; border-radius: 12px; font-size: 18px; font-weight: 900; text-align: center; letter-spacing: 1px; min-width: 120px;';
            div.innerHTML = 'NO DATA';
            return div;
          };
          map.addControl(map._noDataOverlay);
        }
      }

      renderDetails(currentFiltered, previousFiltered);
      renderRiskRings();
      renderThreatHeatmap();

      // Update live activity after rendering
      updateLiveActivity();

      // Check for breaking news after rendering
      checkForBreakingNews();

      // Render activity timeline
      renderActivityTimeline();
    }

    async function fetchIncidents() {
      console.log('fetchIncidents() called, fetching from:', INCIDENTS_URL);

      // Show refresh indicator
      const refreshBadge = document.getElementById('badge-refresh');
      const originalText = refreshBadge.textContent;
      refreshBadge.textContent = '⟳ Updating...';
      refreshBadge.style.background = 'var(--focus)';

      try {
        const res = await fetch(`${INCIDENTS_URL}?_=${Date.now()}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        console.log('fetchIncidents() received data:', data);

        // Demo filtering disabled - now using real incident data
        state.data = data || { generated_utc: null, incidents: [] };
        document.getElementById('badge-generated').textContent = `Generated: ${new Date(state.data.generated_utc).toLocaleString() || '—'}`;

        // Show success indicator briefly
        refreshBadge.textContent = '✓ Updated';
        refreshBadge.style.background = 'var(--severity-3)';
        setTimeout(() => {
          refreshBadge.textContent = originalText;
          refreshBadge.style.background = '';
        }, 2000);

      } catch (err) {
        console.error('Failed to fetch incidents.json', err);
        // Set empty state on error
        state.data = { generated_utc: null, incidents: [] };
        document.getElementById('badge-generated').textContent = 'Generated: Failed to load';

        // Show error indicator
        refreshBadge.textContent = '⚠ Error';
        refreshBadge.style.background = 'var(--severity-4)';
        setTimeout(() => {
          refreshBadge.textContent = originalText;
          refreshBadge.style.background = '';
        }, 3000);
      }
    }

    // Live Activity Functions
    function isLiveIncident(incident) {
      const incidentTime = new Date(incident.first_seen_utc).getTime();
      const now = Date.now();
      const oneHour = 60 * 60 * 1000;

      // Incident is "live" if it occurred within the last hour
      return (now - incidentTime) <= oneHour;
    }

    function updateLiveActivity() {
      const currentLive = new Set();
      const now = Date.now();

      // Find all live incidents
      state.data.incidents.forEach(incident => {
        if (isLiveIncident(incident)) {
          currentLive.add(incident.id);
        }
      });

      // Update live incidents set
      const newLiveIncidents = [...currentLive].filter(id => !state.liveIncidents.has(id));
      const expiredLiveIncidents = [...state.liveIncidents].filter(id => !currentLive.has(id));

      state.liveIncidents = currentLive;

      // Update activity indicator
      updateActivityIndicator();

      // Add pulse animation to new live incident markers
      newLiveIncidents.forEach(incidentId => {
        const marker = state.markers.get(incidentId);
        if (marker && marker.getElement) {
          const element = marker.getElement();
          if (element) {
            element.classList.add('live-marker');
          }
        }
      });

      // Remove pulse animation from expired live incidents
      expiredLiveIncidents.forEach(incidentId => {
        const marker = state.markers.get(incidentId);
        if (marker && marker.getElement) {
          const element = marker.getElement();
          if (element) {
            element.classList.remove('live-marker');
          }
        }
      });

      console.log(`Live activity update: ${currentLive.size} active incidents`, {
        new: newLiveIncidents.length,
        expired: expiredLiveIncidents.length
      });
    }

    function updateActivityIndicator() {
      const indicator = document.getElementById('activity-indicator');
      const activityText = document.getElementById('activity-text');
      const liveCount = state.liveIncidents.size;

      if (liveCount > 0) {
        if (!state.activityIndicatorVisible) {
          indicator.classList.add('visible');
          state.activityIndicatorVisible = true;
        }

        activityText.textContent = liveCount === 1
          ? '1 Live Incident'
          : `${liveCount} Live Incidents`;
      } else {
        if (state.activityIndicatorVisible) {
          indicator.classList.remove('visible');
          state.activityIndicatorVisible = false;
        }
      }
    }

    function addLiveMarkerAnimation(marker) {
      if (marker.getElement) {
        const element = marker.getElement();
        if (element) {
          element.classList.add('live-marker');
        }
      }
    }

    // Breaking News Alert Functions
    let lastAlertTime = 0;
    let shownAlerts = new Set();

    function checkForBreakingNews() {
      const now = Date.now();
      const fifteenMinutes = 15 * 60 * 1000;

      // Find incidents that are less than 15 minutes old and not already shown
      const breakingIncidents = state.data.incidents.filter(incident => {
        const incidentTime = new Date(incident.first_seen_utc).getTime();
        const age = now - incidentTime;
        return age <= fifteenMinutes &&
               age >= 0 && // Not in the future
               !shownAlerts.has(incident.id) &&
               incident.scores?.severity >= 3; // Only show high severity incidents
      });

      if (breakingIncidents.length > 0) {
        // Sort by recency and severity, show the most significant
        const mostSignificant = breakingIncidents.sort((a, b) => {
          const aTime = new Date(a.first_seen_utc).getTime();
          const bTime = new Date(b.first_seen_utc).getTime();
          const aSeverity = a.scores?.severity || 1;
          const bSeverity = b.scores?.severity || 1;

          // Prioritize by severity first, then by recency
          if (bSeverity !== aSeverity) return bSeverity - aSeverity;
          return bTime - aTime;
        })[0];

        showBreakingNewsAlert(mostSignificant);
      }
    }

    function showBreakingNewsAlert(incident) {
      // Don't spam alerts - at least 2 minutes between alerts
      const now = Date.now();
      if (now - lastAlertTime < 120000) return;

      lastAlertTime = now;
      shownAlerts.add(incident.id);

      const alert = document.getElementById('breaking-news-alert');
      const title = document.getElementById('breaking-title');
      const details = document.getElementById('breaking-details');

      // Create breaking news content
      const assetName = incident.asset?.name || 'Unknown Location';
      const assetType = incident.asset?.type || 'facility';
      const timeAgo = getTimeAgo(new Date(incident.first_seen_utc));
      const severity = incident.scores?.severity || 1;

      title.textContent = `${assetType.charAt(0).toUpperCase() + assetType.slice(1)} Incident Detected`;
      details.innerHTML = `
        <strong>${assetName}</strong><br>
        Severity ${severity} • ${timeAgo} • Evidence: ${incident.evidence?.attribution || 'Unknown'}
      `;

      // Show alert with animation
      alert.classList.add('visible');

      // Play notification sound (if user has interacted with page)
      playNotificationSound();

      // Auto-hide after 8 seconds
      setTimeout(() => {
        hideBreakingNewsAlert();
      }, 8000);

      console.log('Breaking news alert shown for incident:', incident.id);
    }

    function hideBreakingNewsAlert() {
      const alert = document.getElementById('breaking-news-alert');
      alert.classList.remove('visible');
    }

    function playNotificationSound() {
      // Create a subtle notification sound using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (error) {
        console.log('Audio notification not available:', error.message);
      }
    }

    function getTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / (1000 * 60));

      if (minutes < 1) return 'Just now';
      if (minutes === 1) return '1 minute ago';
      if (minutes < 60) return `${minutes} minutes ago`;

      const hours = Math.floor(minutes / 60);
      if (hours === 1) return '1 hour ago';
      return `${hours} hours ago`;
    }

    // Activity Timeline Functions
    function renderActivityTimeline() {
      const timeline = document.getElementById('activity-timeline');
      const filtered = filterIncidents('current');

      if (filtered.length === 0) {
        timeline.innerHTML = '<div class="timeline-empty">No incidents in selected time window</div>';
        return;
      }

      // Group incidents by hour
      const hourlyGroups = new Map();
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      // Initialize last 12 hours
      for (let i = 0; i < 12; i++) {
        const hour = new Date(now.getTime() - i * 60 * 60 * 1000);
        const key = `${hour.getDate()}-${hour.getHours()}`;
        hourlyGroups.set(key, {
          hour: hour,
          incidents: [],
          isToday: hour >= today
        });
      }

      // Group incidents by hour
      filtered.forEach(incident => {
        const incidentDate = new Date(incident.first_seen_utc);
        const key = `${incidentDate.getDate()}-${incidentDate.getHours()}`;

        if (hourlyGroups.has(key)) {
          hourlyGroups.get(key).incidents.push(incident);
        }
      });

      // Sort groups by time (most recent first)
      const sortedGroups = Array.from(hourlyGroups.values())
        .sort((a, b) => b.hour - a.hour);

      // Render timeline
      let html = '';
      for (const group of sortedGroups) {
        if (group.incidents.length === 0) continue;

        const hourLabel = group.isToday
          ? (group.hour.getHours() === now.getHours() ? 'This hour' : `${group.hour.getHours()}:00`)
          : group.hour.toLocaleDateString('en-GB', { month: 'short', day: 'numeric', hour: '2-digit' });

        html += `
          <div class="timeline-hour">
            <div class="timeline-hour-label">
              ${hourLabel}
              <span class="timeline-hour-count">${group.incidents.length}</span>
            </div>
            <div class="timeline-incidents">
        `;

        // Sort incidents within hour by time (most recent first)
        const sortedIncidents = group.incidents.sort((a, b) =>
          new Date(b.first_seen_utc) - new Date(a.first_seen_utc)
        );

        for (const incident of sortedIncidents) {
          const assetColor = assetColors[mapAssetType(incident.asset.type)] || '#6ea8fe';
          const assetName = incident.asset.name || 'Unknown Location';
          const time = new Date(incident.first_seen_utc);
          const timeStr = time.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
          const isLive = isLiveIncident(incident);

          html += `
            <div class="timeline-incident ${isLive ? 'live-incident' : ''}" data-incident-id="${incident.id}">
              <div class="timeline-incident-dot" style="background: ${assetColor};"></div>
              <div class="timeline-incident-info">
                <div class="timeline-incident-name" title="${assetName}">
                  ${assetName}
                  ${isLive ? ' 🔴' : ''}
                </div>
                <div class="timeline-incident-time">
                  ${timeStr} • Sev ${incident.scores?.severity || 1} • ${incident.evidence?.attribution || 'Unknown'}
                </div>
              </div>
            </div>
          `;
        }

        html += `
            </div>
          </div>
        `;
      }

      if (html === '') {
        timeline.innerHTML = '<div class="timeline-empty">No recent activity</div>';
      } else {
        timeline.innerHTML = html;

        // Add click handlers for timeline incidents
        timeline.querySelectorAll('.timeline-incident').forEach(element => {
          element.addEventListener('click', (e) => {
            const incidentId = e.currentTarget.getAttribute('data-incident-id');
            const incident = filtered.find(inc => inc.id === incidentId);
            if (incident) {
              focusIncident(incident);
            }
          });
        });
      }
    }

    function autoFocusOnRecentActivity() {
      // Don't auto-focus if disabled by user
      if (!state.autoFocusEnabled) {
        console.log('Auto-focus disabled by user');
        return;
      }

      // Don't auto-focus if user has manually set map position via URL
      const params = new URLSearchParams(window.location.search);
      if (params.has('lat') && params.has('lng')) {
        console.log('Manual map position detected, skipping auto-focus');
        return;
      }

      let targetIncidents = filterIncidents('current');

      // Fallback 1: If no current incidents, try active incidents from any time period
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents.filter(inc => inc.incident.status === 'active');
        console.log('No current incidents, trying active incidents:', targetIncidents.length);
      }

      // Fallback 2: If no active incidents, try high-severity incidents (4+)
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents.filter(inc => inc.scores.severity >= 4);
        console.log('No active incidents, trying high-severity incidents:', targetIncidents.length);
      }

      // Fallback 3: If still none, use all available incidents
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents;
        console.log('No high-severity incidents, using all incidents:', targetIncidents.length);
      }

      // Final fallback: If truly no data, stay with default European view
      if (targetIncidents.length === 0) {
        console.log('No incidents available for auto-focus, keeping default view');
        return;
      }

      // Find most recent incident from available pool
      const mostRecent = targetIncidents.reduce((latest, incident) => {
        const incidentTime = Date.parse(incident.first_seen_utc || incident.last_update_utc);
        const latestTime = Date.parse(latest.first_seen_utc || latest.last_update_utc);
        return incidentTime > latestTime ? incident : latest;
      });

      // Focus on the most recent incident with intelligent zoom level
      const focusLat = mostRecent.asset.lat;
      const focusLng = mostRecent.asset.lon;

      // Smart zoom based on priority factors - showing operational area, not street level
      let zoomLevel = 6; // Regional overview
      if (mostRecent.scores.severity >= 4) zoomLevel = 7; // High severity = city level
      if (mostRecent.incident.status === 'active') zoomLevel = Math.max(zoomLevel, 8); // Active = closer but still operational
      if (mostRecent.asset.type === 'airport') zoomLevel = Math.max(zoomLevel, 7); // Airports = show approaches
      if (Date.now() - Date.parse(mostRecent.first_seen_utc) < 24 * 3600 * 1000) zoomLevel += 0.5; // Recent = slightly closer

      console.log(`Auto-focusing on: ${mostRecent.asset.name} (${mostRecent.asset.type}) | Severity: ${mostRecent.scores.severity} | Status: ${mostRecent.incident.status} | Zoom: ${zoomLevel}`);

      // Smooth animation to the location
      map.flyTo([focusLat, focusLng], zoomLevel, {
        animate: true,
        duration: 2.0 // 2 second smooth animation
      });

      // Show a brief notification about the auto-focus
      showAutoFocusNotification(mostRecent);

      // Open popup after animation completes
      setTimeout(() => {
        const marker = state.markers.get(mostRecent.id);
        if (marker) {
          marker.openPopup();
          // Auto-close popup after 4 seconds
          setTimeout(() => marker.closePopup(), 4000);
        }
      }, 2500);
    }

    function showAutoFocusNotification(incident) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--surface);
        border: 2px solid var(--focus);
        border-radius: 8px;
        padding: 12px 16px;
        color: var(--text);
        font-size: 14px;
        font-weight: 600;
        z-index: 1500;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        animation: slideInRight 0.3s ease-out forwards;
      `;

      const ageDays = Math.floor((Date.now() - Date.parse(incident.first_seen_utc)) / (24 * 3600 * 1000));
      const ageText = ageDays === 0 ? 'today' : ageDays === 1 ? 'yesterday' : `${ageDays} days ago`;

      notification.innerHTML = `
        📍 <strong>Focused on most recent activity</strong><br/>
        <span style="color: var(--muted); font-size: 12px; font-weight: normal;">
          ${incident.asset.name} • ${ageText}
        </span>
      `;

      document.body.appendChild(notification);

      // Remove notification after 5 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease-in forwards';
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 5000);
    }

    async function refreshAll() {
      await fetchIncidents();
      render();

      // Auto-focus on first load only - but let render() handle the map view
      // The render() function now properly shows ALL incidents with fitBounds
      state.hasAutoFocused = true;
    }

    function setupUI() {
      const dateRange = document.getElementById('dateRange');
      const dateLabel = document.getElementById('dateRangeLabel');

      // Load state from URL on init
      loadStateFromURL();

      document.querySelectorAll('.chip[data-window]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.chip[data-window]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          dateRange.value = btn.dataset.window;
          dateLabel.textContent = `Showing last ${dateRange.value} days`;
          render();
          saveStateToURL();
        });
      });

      [
        dateRange,
        document.getElementById('statusSelect'),
        document.getElementById('evidenceSelect'),
        document.getElementById('layer-airport'),
        document.getElementById('layer-harbour'),
        document.getElementById('layer-energy'),
        document.getElementById('layer-rail'),
        document.getElementById('layer-border'),
        document.getElementById('layer-military'),
        document.getElementById('show-risk-rings'),
        document.getElementById('show-threat-heatmap'),
        document.getElementById('compare-mode'),
        document.getElementById('auto-focus')
      ].forEach(control => {
        control.addEventListener('input', () => {
          if (control.id === 'show-risk-rings') {
            state.showRiskRings = control.checked;
          } else if (control.id === 'compare-mode') {
            state.compareMode = control.checked;
            document.getElementById('compare-controls').style.display = control.checked ? 'block' : 'none';
          } else if (control.id === 'auto-focus') {
            state.autoFocusEnabled = control.checked;
          }
          render();
          saveStateToURL();
        });
        control.addEventListener('change', () => {
          if (control.id === 'show-risk-rings') {
            state.showRiskRings = control.checked;
          } else if (control.id === 'show-threat-heatmap') {
            state.showThreatHeatmap = control.checked;
          } else if (control.id === 'compare-mode') {
            state.compareMode = control.checked;
            document.getElementById('compare-controls').style.display = control.checked ? 'block' : 'none';
          } else if (control.id === 'auto-focus') {
            state.autoFocusEnabled = control.checked;
          }
          render();
          saveStateToURL();
        });
      });

      document.getElementById('searchBox').addEventListener('input', () => {
        render();
        saveStateToURL();
      });

      // Breaking news alert close button
      document.getElementById('breaking-close').addEventListener('click', () => {
        hideBreakingNewsAlert();
      });

      // Share button functionality
      document.getElementById('btn-share').addEventListener('click', async () => {
        saveStateToURL();
        try {
          await navigator.clipboard.writeText(window.location.href);
          const btn = document.getElementById('btn-share');
          const originalText = btn.innerHTML;
          btn.innerHTML = '✓ Copied';
          setTimeout(() => btn.innerHTML = originalText, 2000);
        } catch (err) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = window.location.href;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('Link copied to clipboard');
        }
      });

      // Save state on map moves
      map.on('moveend', saveStateToURL);

      // Modal controls
      document.getElementById('closeProvenance').addEventListener('click', hideProvenance);
      document.getElementById('provenanceModal').addEventListener('click', (e) => {
        if (e.target.id === 'provenanceModal') hideProvenance();
      });

      // ESC key to close modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') hideProvenance();
      });

      dateLabel.textContent = `Showing last ${dateRange.value} days`;
    }

    setupUI();
    refreshAll();
    setInterval(refreshAll, REFRESH_MS);
  </script>
</body>
</html>
