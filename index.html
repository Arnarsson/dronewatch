<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DroneWatch — Minimal Threat Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="manifest" href="/manifest.json" />
  <link rel="apple-touch-icon" href="/icon-192.png" />
  <meta name="theme-color" content="#2563EB" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b1220;
      --panel: rgba(17, 24, 39, 0.92);
      --panel-solid: #111c30;
      --surface: #152338;
      --card: #1b2940;
      --accent: #2563eb;
      --accent-strong: #1d4ed8;
      --accent-muted: rgba(37, 99, 235, 0.18);
      --accent-border: rgba(37, 99, 235, 0.4);
      --text: #f8fafc;
      --text-muted: #94a3b8;
      --text-subtle: #cbd5f5;
      --border: rgba(148, 163, 184, 0.18);
      --border-strong: rgba(37, 99, 235, 0.4);
      --success: #38bdf8;
      --warning: #f59e0b;
      --danger: #ef4444;
      --good: #34d399;
      --shadow: 0 30px 60px rgba(8, 15, 30, 0.45);
      --shadow-soft: 0 12px 30px rgba(9, 17, 32, 0.35);
      --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-xs: 0.75rem;
      --font-sm: 0.875rem;
      --font-md: 1rem;
      --font-lg: 1.125rem;
      --font-xl: 1.5rem;
      --space-1: 0.25rem;
      --space-2: 0.5rem;
      --space-3: 0.75rem;
      --space-4: 1rem;
      --space-5: 1.25rem;
      --space-6: 1.5rem;
      --space-8: 2rem;
      --radius: 18px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-family);
      font-size: var(--font-md);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    a { color: inherit; text-decoration: none; }
    button { font: inherit; }

    .classification-banner {
      text-transform: uppercase;
      letter-spacing: 0.18em;
      font-size: var(--font-xs);
      font-weight: 600;
      text-align: center;
      padding: var(--space-2) var(--space-3);
      background: rgba(31, 41, 55, 0.9);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }

    .shell {
      width: min(1280px, 92vw);
      margin: var(--space-6) auto var(--space-8);
      display: flex;
      flex-direction: column;
      gap: var(--space-5);
    }

    header.masthead {
      background: var(--panel);
      border-radius: var(--radius);
      padding: var(--space-5);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      display: grid;
      gap: var(--space-4);
    }

    .masthead__top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: var(--space-4);
      flex-wrap: wrap;
    }

    .brand-block h1 {
      margin: 0;
      font-size: 2rem;
      letter-spacing: -0.02em;
    }

    .brand-block p {
      margin: 0;
      font-size: var(--font-sm);
      color: var(--text-muted);
    }

    .masthead__meta {
      display: flex;
      align-items: center;
      gap: var(--space-3);
    }

    .time-chip {
      display: inline-flex;
      align-items: center;
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-subtle);
    }

    .share-btn {
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      border: 1px solid var(--accent-border);
      background: rgba(37, 99, 235, 0.16);
      color: var(--text);
      cursor: pointer;
      transition: 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
    }

    .share-btn:hover {
      background: rgba(37, 99, 235, 0.28);
      border-color: rgba(37, 99, 235, 0.6);
      transform: translateY(-1px);
    }

    .masthead__status {
      display: flex;
      gap: var(--space-4);
      flex-wrap: wrap;
      color: var(--text-muted);
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: var(--space-2);
      background: var(--good);
      box-shadow: 0 0 12px rgba(52, 211, 153, 0.5);
      display: inline-block;
    }

    .status-dot.degraded { background: var(--warning); box-shadow: 0 0 12px rgba(245, 158, 11, 0.4); }

    .badge-row {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .badge.live {
      background: rgba(52, 211, 153, 0.18);
      color: #bbf7d0;
      border-color: rgba(52, 211, 153, 0.4);
    }

    .badge.badge-action {
      cursor: pointer;
      background: var(--accent-muted);
      border-color: var(--accent-border);
      color: var(--text);
      transition: 0.2s ease;
    }

    .badge.badge-action:hover {
      background: rgba(37, 99, 235, 0.26);
    }

    .breaking-banner {
      display: none;
      flex-direction: column;
      gap: var(--space-2);
      background: rgba(239, 68, 68, 0.12);
      border: 1px solid rgba(239, 68, 68, 0.38);
      border-radius: var(--radius);
      padding: var(--space-4);
    }

    .breaking-banner.visible { display: flex; }

    .breaking-news-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      font-size: var(--font-sm);
    }

    .breaking-badge {
      text-transform: uppercase;
      font-size: var(--font-xs);
      padding: var(--space-1) var(--space-3);
      border-radius: 999px;
      background: rgba(239, 68, 68, 0.3);
      color: #fecaca;
    }

    .breaking-close {
      margin-left: auto;
      background: transparent;
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--text);
      border-radius: 999px;
      width: 28px;
      height: 28px;
      cursor: pointer;
    }

    .critical-strip {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: var(--space-4);
      display: grid;
      gap: var(--space-3);
    }

    .critical-strip > header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: var(--font-sm);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .critical-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: var(--space-3);
    }

    .critical-card {
      background: rgba(37, 99, 235, 0.12);
      border: 1px solid var(--accent-border);
      border-radius: 14px;
      padding: var(--space-3);
      display: grid;
      gap: var(--space-2);
      text-align: left;
      cursor: pointer;
      transition: 0.2s ease;
    }

    .critical-card:hover {
      border-color: rgba(37, 99, 235, 0.6);
      background: rgba(37, 99, 235, 0.2);
    }

    .critical-card__header {
      display: flex;
      gap: var(--space-2);
      align-items: center;
      font-weight: 600;
    }

    .critical-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(37, 99, 235, 0.5);
    }

    .critical-dot.severity-4 { background: var(--accent-strong); }
    .critical-dot.severity-5 { background: var(--danger); box-shadow: 0 0 12px rgba(239, 68, 68, 0.6); }

    .critical-time {
      margin-left: auto;
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .critical-meta { font-size: var(--font-xs); color: var(--text-muted); }

    .stats-strip {
      display: grid;
      gap: var(--space-3);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: var(--space-3);
    }

    .stat-card {
      background: var(--panel);
      border-radius: var(--radius);
      padding: var(--space-4);
      border: 1px solid var(--border);
      display: grid;
      gap: var(--space-2);
      min-height: 140px;
    }

    .stat-label {
      font-size: var(--font-xs);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: -0.03em;
    }

    .stat-change {
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(280px, 0.85fr);
      gap: var(--space-4);
    }

    .map-panel {
      display: grid;
      gap: var(--space-3);
    }

    .map-panel__top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-3);
      flex-wrap: wrap;
    }

    #activity-indicator {
      display: inline-flex;
      align-items: center;
      gap: var(--space-3);
      background: rgba(37, 99, 235, 0.12);
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      border: 1px solid var(--accent-border);
      color: var(--text-muted);
      font-size: var(--font-xs);
      transition: 0.2s ease;
    }

    .activity-pulse {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px rgba(37, 99, 235, 0.5);
      animation: pulse 2.4s infinite;
    }

    .threat-level-indicator {
      display: flex;
      align-items: center;
      gap: var(--space-3);
    }

    .threat-level-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--warning);
      box-shadow: 0 0 14px rgba(245, 158, 11, 0.4);
    }

    #activity-indicator.visible {
      background: rgba(37, 211, 102, 0.16);
      border-color: rgba(37, 211, 102, 0.4);
      color: #bbf7d0;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
    }

    .filters-toggle {
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      transition: 0.2s ease;
    }

    .filters-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .map-shell {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      overflow: hidden;
      position: relative;
      min-height: 520px;
      box-shadow: var(--shadow-soft);
    }

    #map-container { position: relative; height: 100%; }
    #map { width: 100%; height: 100%; }

    .map-hint {
      position: absolute;
      top: var(--space-3);
      left: var(--space-3);
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      background: rgba(10, 17, 33, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 10;
    }

    #mapOverlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: var(--space-2);
      background: rgba(11, 18, 32, 0.82);
      backdrop-filter: blur(6px);
      z-index: 20;
      text-align: center;
    }

    #mapOverlay h3 {
      margin: 0;
      letter-spacing: 0.2em;
      font-size: 1.75rem;
    }

    .side-area {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-soft);
      display: grid;
    }

    .panel-tabs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      background: rgba(255, 255, 255, 0.03);
      padding: var(--space-2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .panel-tab {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: var(--space-2) var(--space-3);
      border-radius: 12px;
      font-size: var(--font-xs);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: 0.2s ease;
    }

    .panel-tab.active {
      background: rgba(37, 99, 235, 0.2);
      color: var(--text);
    }

    .panel-panes {
      padding: var(--space-4);
      display: grid;
    }

    .panel-pane { display: none; gap: var(--space-3); }
    .panel-pane.active { display: grid; }

    .muted { color: var(--text-muted); font-size: var(--font-sm); }

    #noDataMessage {
      display: none;
      border: 1px dashed rgba(148, 163, 184, 0.3);
      border-radius: 16px;
      padding: var(--space-5) var(--space-3);
      text-align: center;
      background: rgba(255, 255, 255, 0.03);
    }

    #incidentList {
      display: grid;
      gap: var(--space-3);
    }

    .incident {
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: var(--surface);
      padding: var(--space-3);
      display: grid;
      gap: var(--space-2);
      cursor: pointer;
      transition: 0.2s ease;
    }

    .incident:hover {
      border-color: rgba(37, 99, 235, 0.5);
      transform: translateY(-1px);
    }

    .incident-header {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      justify-content: space-between;
      font-weight: 600;
    }

    .incident-meta {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2) var(--space-3);
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .incident-tags {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .incident-tags span {
      padding: var(--space-1) var(--space-3);
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      font-size: var(--font-xs);
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .news-feed {
      display: grid;
      gap: var(--space-2);
    }

    .news-item {
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.03);
      padding: var(--space-3);
      display: grid;
      gap: var(--space-2);
      text-align: left;
      transition: 0.2s ease;
      cursor: pointer;
    }

    .news-item:hover { border-color: rgba(37, 99, 235, 0.4); }

    .news-item__header { display: flex; gap: var(--space-2); align-items: center; }
    .news-headline { font-weight: 600; }
    .news-meta { margin-left: auto; font-size: var(--font-xs); color: var(--text-muted); }
    .news-body { font-size: var(--font-xs); color: var(--text-muted); }
    .news-footer { display: flex; align-items: center; gap: var(--space-2); font-size: var(--font-xs); color: var(--text-muted); }
    .news-tag { margin-left: auto; padding: var(--space-1) var(--space-3); border-radius: 999px; background: var(--accent-muted); border: 1px solid var(--accent-border); text-transform: uppercase; letter-spacing: 0.08em; font-size: var(--font-xs); }

    .activity-timeline {
      max-height: 280px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.02);
      overflow-y: auto;
    }

    .timeline-loading { padding: var(--space-4); text-align: center; font-size: var(--font-xs); color: var(--text-muted); }

    .statbar-section { display: none; }
    .statbar {
      display: flex;
      gap: var(--space-3);
      flex-wrap: wrap;
    }

    .statbar .stat {
      background: var(--panel);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: var(--space-3);
      flex: 1 1 140px;
    }

    .statbar .k {
      font-size: 1.5rem;
      font-weight: 600;
    }

    .filters-overlay {
      position: fixed;
      inset: 0;
      background: rgba(8, 13, 23, 0.75);
      backdrop-filter: blur(12px);
      display: none;
      align-items: center;
      justify-content: flex-start;
      padding: var(--space-6);
      z-index: 1200;
    }

    .filters-overlay.open { display: flex; }

    .filters-sheet {
      width: min(360px, 92vw);
      max-height: 100%;
      overflow-y: auto;
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      padding: var(--space-5);
      box-shadow: var(--shadow);
      display: grid;
      gap: var(--space-4);
    }

    .filters-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .filters-header h2 {
      margin: 0;
      font-size: 1.125rem;
      letter-spacing: -0.01em;
    }

    .filters-close {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 999px;
      width: 32px;
      height: 32px;
      color: var(--text);
      cursor: pointer;
    }

    details.module {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      overflow: hidden;
    }

    details.module summary {
      list-style: none;
      padding: var(--space-3) var(--space-4);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      font-size: var(--font-xs);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
      cursor: pointer;
    }

    details.module summary::-webkit-details-marker { display: none; }
    details.module summary::after { content: '\25BC'; margin-left: auto; font-size: 0.75rem; transition: transform 0.2s ease; }
    details.module[open] summary::after { transform: rotate(-180deg); }

    details.module .module-content {
      padding: var(--space-3) var(--space-4) var(--space-4);
      display: grid;
      gap: var(--space-3);
    }

    .chips {
      display: flex;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .chip {
      padding: var(--space-2) var(--space-4);
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      font-size: var(--font-xs);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: 0.2s ease;
    }

    .chip.active { background: var(--accent); border-color: rgba(37, 99, 235, 0.6); color: #fff; }

    .toggle-group { display: grid; gap: var(--space-2); }
    .toggle { display: flex; align-items: center; gap: var(--space-2); font-size: var(--font-sm); color: var(--text-muted); }

    input[type='checkbox'] { accent-color: var(--accent); }

    select, input[type='text'], input[type='search'], input[type='range'] {
      width: 100%;
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 10px;
      padding: var(--space-3);
      background: rgba(13, 20, 36, 0.72);
      color: var(--text);
    }

    select[multiple] { min-height: 140px; }

    input[type='range'] {
      height: 4px;
      background: transparent;
    }

    .bottom-sheet, .mobile-nav, .fab { display: none; }

    #provenanceModal {
      position: fixed;
      inset: 0;
      background: rgba(8, 13, 23, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      padding: var(--space-6);
      z-index: 1400;
    }

    #provenanceModal.open { display: flex; }

    .provenance-modal-content {
      width: min(720px, 96vw);
      max-height: 90vh;
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }

    .provenance-modal-header {
      padding: var(--space-4);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .provenance-modal-body { padding: var(--space-4); overflow-y: auto; }

    @media (max-width: 1080px) {
      .layout { grid-template-columns: 1fr; }
      .map-shell { min-height: 420px; }
      .side-area { order: 2; }
    }

    @media (max-width: 900px) {
      .shell { width: min(96vw, 720px); margin: var(--space-4) auto var(--space-10); }
      header.masthead { padding: var(--space-4); }
      .critical-list { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
      .stats-grid { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
      .panel-tabs { grid-template-columns: repeat(3, minmax(0, 1fr)); }
      .bottom-sheet, .mobile-nav, .fab { display: block; }
      body.filters-open { overflow: hidden; }
    }

    .mobile-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(9, 15, 28, 0.95);
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      padding: var(--space-2);
      z-index: 1300;
      backdrop-filter: blur(18px);
    }

    .mobile-nav-items {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--space-2);
    }

    .mobile-nav-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-1);
      padding: var(--space-3) var(--space-2);
      border-radius: 12px;
      font-size: var(--font-xs);
      color: var(--text-muted);
    }

    .mobile-nav-item.active { background: rgba(37, 99, 235, 0.22); color: var(--text); }

    .fab {
      position: fixed;
      bottom: 4.5rem;
      right: 1.25rem;
      width: 3.25rem;
      height: 3.25rem;
      border-radius: 50%;
      background: var(--accent);
      color: #fff;
      border: none;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--shadow);
      cursor: pointer;
      z-index: 1300;
    }

    .bottom-sheet {
      position: fixed;
      left: 0;
      right: 0;
      bottom: -100%;
      background: rgba(9, 15, 28, 0.96);
      border-radius: 24px 24px 0 0;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: var(--space-4) var(--space-4) calc(var(--space-6) + 60px);
      max-height: 80vh;
      overflow-y: auto;
      transition: transform 0.3s ease;
      z-index: 1350;
    }

    .bottom-sheet.open { transform: translateY(-100%); }

    .bottom-sheet-handle {
      width: 46px;
      height: 4px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.5);
      margin: 0 auto var(--space-3);
    }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); }
    ::-webkit-scrollbar-thumb { background: rgba(148, 163, 184, 0.45); border-radius: 10px; }

    .live-marker {
      animation: markerPulse 1.8s infinite;
      transform-origin: center;
    }

    @keyframes markerPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }

    @supports (color: color(display-p3 1 1 1)) {
      body { color-scheme: dark; }
    }
  </style>
</head>

<body>
  <div class="classification-banner unclassified">UNCLASSIFIED // FOR OFFICIAL USE ONLY</div>
  <div class="shell">
    <header class="masthead">
      <div class="masthead__top">
        <div class="brand-block">
          <h1>DroneWatch</h1>
          <p>Minimal operations dashboard for high-stakes drone threat response</p>
        </div>
        <div class="masthead__meta">
          <div class="time-chip" id="system-time">00:00:00Z</div>
          <button class="share-btn" id="btn-share" type="button">Share secure view</button>
          <button class="filters-toggle" id="filters-toggle" type="button" aria-expanded="false">Filters</button>
        </div>
      </div>
      <div class="masthead__status">
        <span><span class="status-dot"></span>Radar Grid</span>
        <span><span class="status-dot"></span>Comms Link</span>
        <span><span class="status-dot"></span>Incident Feed</span>
      </div>
    </header>

    <div class="badge-row">
      <span class="badge live">Live</span>
      <span class="badge" id="badge-refresh">Auto-sync</span>
      <span class="badge" id="badge-generated">Updated: —</span>
      <span class="badge" id="badge-status" style="display:none;">No Data</span>
      <button class="badge badge-action" id="ai-fetch-btn" type="button">🤖 AI News</button>
    </div>

    <div class="breaking-banner" id="breaking-news-alert" role="status" aria-live="assertive">
      <div class="breaking-news-header">
        <span class="breaking-badge">Breaking</span>
        <strong id="breaking-title"></strong>
        <button id="breaking-close" class="breaking-close" type="button">×</button>
      </div>
      <div id="breaking-details" class="breaking-details"></div>
    </div>

    <section class="critical-strip" aria-label="Critical alerts">
      <header>Critical alerts</header>
      <div class="critical-list" id="critical-alerts">
        <p class="empty-state muted">Awaiting incident data.</p>
      </div>
    </section>

    <section class="stats-strip" aria-label="Operational summary">
      <div class="stats-grid">
        <article class="stat-card">
          <span class="stat-label">Active now</span>
          <span class="stat-value" id="stat-active">0</span>
          <span class="stat-change" id="stat-active-change">—</span>
        </article>
        <article class="stat-card">
          <span class="stat-label">Past 24 hours</span>
          <span class="stat-value" id="stat-24h">0</span>
          <span class="stat-change" id="stat-24h-change">—</span>
        </article>
        <article class="stat-card">
          <span class="stat-label">High severity</span>
          <span class="stat-value" id="stat-severity">0</span>
          <div class="stat-change">
            <div id="severity-bar" style="height:4px; border-radius: 999px; background: var(--accent); width:0%"></div>
          </div>
        </article>
        <article class="stat-card">
          <span class="stat-label">Assets impacted</span>
          <span class="stat-value" id="stat-assets">0</span>
          <span class="stat-change" id="stat-assets-detail">—</span>
        </article>
        <article class="stat-card">
          <span class="stat-label">7-day trend</span>
          <canvas id="trend-chart" width="200" height="60"></canvas>
        </article>
      </div>
    </section>

    <div class="layout">
      <section class="map-panel">
        <div class="map-panel__top">
          <div id="activity-indicator">
            <span class="activity-pulse"></span>
            <div>
              <strong id="activity-text">Live activity</strong>
              <span class="muted">Streaming incident telemetry</span>
            </div>
          </div>
        </div>
        <div class="map-shell">
          <div id="map-container">
            <div class="map-hint">Scroll to zoom • Shift + drag to focus • Double-click to recenter</div>
            <div id="map" role="region" aria-label="Incident map"></div>
            <div id="mapOverlay">
              <h3>NO DATA</h3>
              <p class="muted">No incidents match the current filters</p>
            </div>
          </div>
        </div>
      </section>

      <aside id="right" class="side-area" aria-label="Incident intelligence">
        <div class="panel-tabs" role="tablist">
          <button class="panel-tab active" data-panel="incidents" type="button">Incidents</button>
          <button class="panel-tab" data-panel="intel" type="button">Intel brief</button>
          <button class="panel-tab" data-panel="timeline" type="button">Timeline</button>
        </div>
        <div class="panel-panes">
          <section class="panel-pane active" data-panel="incidents">
            <p class="muted" id="detailsIntro">Interactive feed of active incidents. Select a row to focus on the map.</p>
            <div id="noDataMessage">
              <strong style="letter-spacing:0.2em; text-transform:uppercase;">No matches</strong>
              <p class="muted">Adjust filters or expand the time window to widen coverage.</p>
            </div>
            <div id="incidentList"></div>
          </section>
          <section class="panel-pane" data-panel="intel">
            <p class="muted" style="font-size: var(--font-xs);">Triggered by the AI News button for targeted intelligence. No monetized content.</p>
            <div class="news-feed" id="news-feed">
              <p class="empty-state muted">AI-assisted news brief will appear here.</p>
            </div>
          </section>
          <section class="panel-pane" data-panel="timeline">
            <div id="activity-timeline" class="activity-timeline">
              <div class="timeline-loading">Loading timeline...</div>
            </div>
          </section>
        </div>
      </aside>
    </div>

    <section class="statbar-section" aria-label="Category summary">
      <div class="statbar">
        <div class="stat"><div class="k" id="stat-total">0</div><div class="muted">Incidents</div></div>
        <div class="stat"><div class="k" id="stat-air">0</div><div class="muted">Airspace</div></div>
        <div class="stat"><div class="k" id="stat-har">0</div><div class="muted">Harbours</div></div>
      </div>
    </section>
  </div>

  <div id="left" class="filters-overlay" aria-hidden="true">
    <aside class="filters-sheet" role="dialog" aria-labelledby="filters-title">
      <div class="filters-header">
        <h2 id="filters-title">Filters</h2>
        <button id="filters-close" class="filters-close" type="button">×</button>
      </div>
      <div class="filters-content">
        <details class="module" open>
          <summary>Threat posture</summary>
          <div class="module-content">
            <div class="threat-level-indicator">
              <div class="threat-level-dot medium" id="current-threat-level"></div>
              <div>
                <div style="font-weight:600;">Elevated</div>
                <div class="muted" style="font-size: var(--font-xs);">Monitoring critical European infrastructure</div>
              </div>
            </div>
          </div>
        </details>
        <details class="module" open>
          <summary>Time window</summary>
          <div class="module-content">
            <div class="chips">
              <button class="chip active" data-window="7" type="button">7d</button>
              <button class="chip" data-window="30" type="button">30d</button>
              <button class="chip" data-window="90" type="button">90d</button>
              <button class="chip" data-window="365" type="button">365d</button>
            </div>
            <label for="dateRange" class="muted">Select range (days)</label>
            <input id="dateRange" type="range" min="1" max="365" value="7" step="1" />
            <div class="muted" id="dateRangeLabel">Showing last 7 days</div>
          </div>
        </details>
        <details class="module" open>
          <summary>Asset layers</summary>
          <div class="module-content">
            <div class="toggle-group">
              <label class="toggle"><input type="checkbox" id="layer-airport" checked />Airports &amp; aviation</label>
              <label class="toggle"><input type="checkbox" id="layer-harbour" checked />Harbours</label>
              <label class="toggle"><input type="checkbox" id="layer-energy" checked />Energy</label>
              <label class="toggle"><input type="checkbox" id="layer-rail" checked />Rail &amp; transit</label>
              <label class="toggle"><input type="checkbox" id="layer-border" checked />Border crossings</label>
              <label class="toggle"><input type="checkbox" id="layer-military" checked />Military</label>
            </div>
          </div>
        </details>
        <details class="module">
          <summary>Infrastructure proximity</summary>
          <div class="module-content">
            <p class="muted" style="font-size: var(--font-xs);">Highlight incidents within 10km of key infrastructure</p>
            <label class="toggle"><input type="checkbox" id="filter-near-harbours" />Near harbours</label>
            <label class="toggle"><input type="checkbox" id="filter-near-military" />Near military bases</label>
            <label class="toggle"><input type="checkbox" id="filter-near-airports" />Near airports</label>
          </div>
        </details>
        <details class="module">
          <summary>Risk visualisation</summary>
          <div class="module-content">
            <label class="toggle"><input type="checkbox" id="show-risk-rings" checked />Show risk rings</label>
            <label class="toggle"><input type="checkbox" id="show-threat-heatmap" />Threat heatmap</label>
            <label class="toggle"><input type="checkbox" id="auto-focus" checked />Auto-focus on new incidents</label>
            <label class="toggle"><input type="checkbox" id="compare-mode" />Compare previous period</label>
            <div id="compare-controls" class="muted" style="display:none; font-size: var(--font-xs);">Comparing current vs previous window</div>
          </div>
        </details>
        <details class="module">
          <summary>Status &amp; evidence</summary>
          <div class="module-content">
            <label for="statusSelect" class="muted">Status</label>
            <select id="statusSelect" multiple>
              <option value="active" selected>Active</option>
              <option value="resolved" selected>Resolved</option>
              <option value="unconfirmed" selected>Unconfirmed</option>
            </select>
            <label for="evidenceSelect" class="muted">Evidence strength</label>
            <select id="evidenceSelect" multiple>
              <option value="3" selected>3 — Official / NOTAM</option>
              <option value="2" selected>2 — Tier-1 corroborated</option>
              <option value="1" selected>1 — Single credible</option>
              <option value="0" selected>0 — Unconfirmed</option>
            </select>
          </div>
        </details>
        <details class="module">
          <summary>Search</summary>
          <div class="module-content">
            <label for="searchBox" class="muted">Free-text search</label>
            <input id="searchBox" type="text" placeholder="e.g., Nordhavn, NOTAM, Oslo" />
          </div>
        </details>
      </div>
    </aside>
  </div>

  <div id="provenanceModal" class="provenance-modal" aria-hidden="true">
    <div class="provenance-modal-content">
      <div class="provenance-modal-header">
        <h2 class="provenance-modal-title">Incident provenance</h2>
        <button id="closeProvenance" class="filters-close" type="button">✕</button>
      </div>
      <div id="provenanceContent" class="provenance-modal-body"></div>
    </div>
  </div>

  <nav class="mobile-nav" id="mobile-nav">
    <div class="mobile-nav-items">
      <a href="#" class="mobile-nav-item active" data-tab="map">🗺️<span class="mobile-nav-label">Map</span></a>
      <a href="#" class="mobile-nav-item" data-tab="incidents">🚨<span class="mobile-nav-label">Incidents</span></a>
      <a href="#" class="mobile-nav-item" data-tab="filters">⚙️<span class="mobile-nav-label">Filters</span></a>
      <a href="#" class="mobile-nav-item" data-tab="stats">📊<span class="mobile-nav-label">Stats</span></a>
    </div>
  </nav>

  <button class="fab" id="mobile-fab" type="button" aria-label="Toggle mobile controls">⚡</button>

  <div class="bottom-sheet" id="mobile-bottom-sheet">
    <div class="bottom-sheet-handle"></div>
    <div id="bottom-sheet-content"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin="anonymous"></script>
<script>
    const INCIDENTS_URL = './incidents.json';
    const REFRESH_MS = 5 * 60 * 1000;

    // AI API Configuration for real-time news
    const AI_CONFIG = {
      // OpenRouter API (recommended - best free models)
      OPENROUTER_API_URL: 'https://openrouter.ai/api/v1/chat/completions',
      OPENROUTER_API_KEY: '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', // OpenRouter API key

      // Best free models on OpenRouter (ordered by recommendation):
      FREE_MODELS: [
        'x-ai/grok-4-fast:free',                        // Grok-4 Fast - very fast and capable
        'microsoft/phi-3-mini-128k-instruct:free',      // Excellent for analysis, 128K context
        'meta-llama/llama-3.1-8b-instruct:free',       // Great reasoning, fast
        'google/gemma-2-9b-it:free',                    // Google's latest, very capable
        'mistralai/mistral-7b-instruct:free',          // Good for structured tasks
        'huggingface/zephyr-7b-beta:free'              // Reliable fallback
      ],

      // RSS news feeds for drone incidents
      NEWS_SOURCES: [
        'https://feeds.reuters.com/reuters/topNews',
        'https://rss.cnn.com/rss/edition.rss',
        'https://feeds.bbci.co.uk/news/world/rss.xml'
      ]
    };

    // Infrastructure data for proximity filtering
    window.infrastructureData = {
      harbours: [],
      military: [],
      airports: []
    };

    async function loadInfrastructureDataForFiltering() {
      console.log('Loading infrastructure data for proximity filtering...');
      const infrastructureTypes = [
        { name: 'harbours', file: 'harbours.geojson' },
        { name: 'military', file: 'military.geojson' },
        { name: 'airports_wikidata', file: 'airports_wikidata.geojson' }
      ];

      for (const infra of infrastructureTypes) {
        try {
          const response = await fetch(`data/assets/${infra.file}`);
          if (response.ok) {
            const data = await response.json();
            if (data.features && data.features.length > 0) {
              // Store for proximity filtering
              if (infra.name === 'airports_wikidata') {
                window.infrastructureData.airports = data.features;
              } else {
                window.infrastructureData[infra.name] = data.features;
              }
              console.log(`Loaded ${data.features.length} ${infra.name} for filtering`);
            }
          }
        } catch (error) {
          console.error(`Error loading ${infra.name} for filtering:`, error);
        }
      }
    }

    // Function to check if incident is near infrastructure
    function isNearInfrastructure(incident, infrastructureType, maxDistanceKm = 10) {
      if (!window.infrastructureData[infrastructureType]) return false;

      const incidentLat = incident.lat || incident.latitude;
      const incidentLng = incident.lng || incident.longitude;

      if (!incidentLat || !incidentLng) return false;

      return window.infrastructureData[infrastructureType].some(feature => {
        if (feature.geometry && feature.geometry.type === 'Point') {
          const [lng, lat] = feature.geometry.coordinates;
          const distance = calculateDistance(incidentLat, incidentLng, lat, lng);
          return distance <= maxDistanceKm;
        }
        return false;
      });
    }

    // Haversine formula for distance calculation
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Global state and functions for mobile access
    window.droneState = null;
    window.droneFocusIncident = null;

    // Operations Center Functions
    function updateSystemTime() {
      const now = new Date();
      const utcTime = now.toISOString().substr(11, 8) + 'Z';
      const timeElement = document.getElementById('system-time');
      if (timeElement) {
        timeElement.textContent = utcTime;
      }
    }

    function updateThreatLevel() {
      const incidents = (window.droneState && window.droneState.incidents) ? window.droneState.incidents : [];
      let threatLevel = 'low';
      let threatClass = 'low';
      let threatText = 'MINIMAL';

      if (incidents.length > 10) {
        threatLevel = 'critical';
        threatClass = 'critical';
        threatText = 'CRITICAL';
      } else if (incidents.length > 5) {
        threatLevel = 'high';
        threatClass = 'high';
        threatText = 'ELEVATED';
      } else if (incidents.length > 2) {
        threatLevel = 'medium';
        threatClass = 'medium';
        threatText = 'ELEVATED';
      }

      const dot = document.getElementById('current-threat-level');
      if (dot) {
        dot.className = `threat-level-dot ${threatClass}`;
      }

      // Update threat level text
      const indicator = document.querySelector('.threat-level-indicator div:last-child div:first-child');
      if (indicator) {
        indicator.textContent = threatText;
      }
    }

        function setupFilterDrawer(root = document) {
      const drawer = root.getElementById ? root.getElementById('left') : document.getElementById('left');
      const openBtn = root.getElementById ? root.getElementById('filters-toggle') : document.getElementById('filters-toggle');
      const closeBtn = root.getElementById ? root.getElementById('filters-close') : document.getElementById('filters-close');

      if (!drawer || !openBtn) return;

      const toggleDrawer = (open) => {
        if (open) {
          drawer.classList.add('open');
          drawer.setAttribute('aria-hidden', 'false');
          openBtn.setAttribute('aria-expanded', 'true');
          document.body.classList.add('filters-open');
        } else {
          drawer.classList.remove('open');
          drawer.setAttribute('aria-hidden', 'true');
          openBtn.setAttribute('aria-expanded', 'false');
          document.body.classList.remove('filters-open');
        }
      };

      openBtn.addEventListener('click', () => {
        const isOpen = drawer.classList.contains('open');
        toggleDrawer(!isOpen);
      });

      if (closeBtn) {
        closeBtn.addEventListener('click', () => toggleDrawer(false));
      }

      drawer.addEventListener('click', (event) => {
        if (event.target === drawer) {
          toggleDrawer(false);
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && drawer.classList.contains('open')) {
          toggleDrawer(false);
        }
      });
    }

    function setupPanelTabs(root = document) {
      const tabButtons = root.querySelectorAll ? root.querySelectorAll('.panel-tab') : [];
      const panes = root.querySelectorAll ? root.querySelectorAll('.panel-pane') : [];
      if (!tabButtons.length || !panes.length) return;

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const target = button.dataset.panel;
          tabButtons.forEach(btn => btn.classList.toggle('active', btn === button));
          panes.forEach(pane => pane.classList.toggle('active', pane.dataset.panel === target));
        });
      });
    }

function initializeOperationsCenter() {
      // Start system time updates
      updateSystemTime();
      setInterval(updateSystemTime, 1000);

      // Initialize threat level
      updateThreatLevel();

      // Load infrastructure data for proximity filtering (not display)
      loadInfrastructureDataForFiltering();

      // Update status indicators based on system state
      const statusIndicators = document.querySelectorAll('.status-dot');
      statusIndicators.forEach(dot => {
        if (Math.random() < 0.1) {
          dot.className = 'status-dot degraded';
        }
      });

      // Wire up UI helpers
      setupFilterDrawer();
      setupPanelTabs();
    }

    async function loadInfrastructureData() {
      console.log('Loading infrastructure data...');

      // Load different infrastructure types
      const infrastructureTypes = [
        { name: 'harbours', file: 'harbours.geojson', color: '#3b82f6', icon: '⚓' },
        { name: 'airports_wikidata', file: 'airports_wikidata.geojson', color: '#10b981', icon: '✈️' },
        { name: 'fallback', file: 'fallback.geojson', color: '#ef4444', icon: '🏛️' }
      ];

      for (const infra of infrastructureTypes) {
        try {
          const response = await fetch(`data/assets/${infra.file}`);
          if (!response.ok) {
            console.warn(`Failed to load ${infra.name}: ${response.status}`);
            continue;
          }

          const data = await response.json();
          console.log(`Loaded ${infra.name}: ${data.features.length} features`);

          // Add to map if map exists
          if (window.map && data.features.length > 0) {
            addInfrastructureLayer(infra.name, data, infra.color, infra.icon);
          }

        } catch (error) {
          console.error(`Error loading ${infra.name}:`, error);
        }
      }
    }

    function addInfrastructureLayer(name, data, color, icon) {
      if (!window.map) return;

      // Create marker cluster group for this infrastructure type
      const cluster = L.markerClusterGroup({
        iconCreateFunction: function(cluster) {
          const count = cluster.getChildCount();
          return L.divIcon({
            html: `<div style="background:${color};color:white;border-radius:50%;width:40px;height:40px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;">${count}</div>`,
            className: 'custom-cluster-icon',
            iconSize: [40, 40]
          });
        }
      });

      // Add markers for each feature
      data.features.forEach(feature => {
        if (feature.geometry.type === 'Point') {
          const [lng, lat] = feature.geometry.coordinates;
          const props = feature.properties;

          const marker = L.marker([lat, lng], {
            icon: L.divIcon({
              html: `<div style="background:${color};color:white;border-radius:50%;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:10px;">${icon}</div>`,
              className: 'infrastructure-marker',
              iconSize: [20, 20]
            })
          });

          // Add popup with facility information
          const popupContent = `
            <div style="font-family: 'Inter', sans-serif;">
              <h3 style="margin:0 0 8px 0;color:#1e293b;font-size:14px;">${props.name || 'Infrastructure Facility'}</h3>
              <p style="margin:0;color:#64748b;font-size:12px;">Type: ${name}</p>
              ${props.iata ? `<p style="margin:0;color:#64748b;font-size:12px;">IATA: ${props.iata}</p>` : ''}
              ${props.icao ? `<p style="margin:0;color:#64748b;font-size:12px;">ICAO: ${props.icao}</p>` : ''}
            </div>
          `;

          marker.bindPopup(popupContent);
          cluster.addLayer(marker);
        }
      });

      // Add cluster to map
      window.map.addLayer(cluster);

      // Store reference for layer control
      if (!window.infrastructureLayers) {
        window.infrastructureLayers = {};
      }
      window.infrastructureLayers[name] = cluster;

      console.log(`Added ${name} layer with ${data.features.length} features`);
    }

    // Wait for DOM to be ready before initializing map
    function initializeMap() {
      // Check if map element exists
      const mapElement = document.getElementById('map');
      if (!mapElement) {
        console.error('Map element not found!');
        setTimeout(initializeMap, 100); // Retry after 100ms
        return;
      }

      // CRITICAL: Check if container has actual dimensions
      const mapContainer = document.getElementById('map-container');
      if (!mapContainer || mapContainer.offsetWidth === 0 || mapContainer.offsetHeight === 0) {
        console.log('Map container has no dimensions yet, retrying...');
        setTimeout(initializeMap, 200);
        return;
      }

      console.log('Map container dimensions:', mapContainer.offsetWidth, 'x', mapContainer.offsetHeight);
      console.log('Initializing map...');

      const assetColors = {
        airport: getComputedStyle(document.documentElement).getPropertyValue('--air') || '#ef4444',
        harbour: getComputedStyle(document.documentElement).getPropertyValue('--harbour') || '#3b82f6',
        energy: getComputedStyle(document.documentElement).getPropertyValue('--energy') || '#f97316',
        rail: getComputedStyle(document.documentElement).getPropertyValue('--rail') || '#22c55e',
        border: getComputedStyle(document.documentElement).getPropertyValue('--border-crossing') || '#eab308',
        military: getComputedStyle(document.documentElement).getPropertyValue('--military') || '#c084fc'
      };

      // Make map global for debugging
      window.map = L.map('map', {
        center: [56, 12],
        zoom: 4,
        minZoom: 3,
        worldCopyJump: true
      });

      const map = window.map; // Keep local reference
      console.log('Map reference created, about to continue initialization');

      // CRITICAL: Force map to recalculate size on mobile
      setTimeout(() => {
        map.invalidateSize();
        console.log('Map size invalidated');
      }, 100);

      // Also invalidate on window resize
      window.addEventListener('resize', () => {
        map.invalidateSize();
      });

      // Force another invalidation after a delay for mobile
      setTimeout(() => {
        map.invalidateSize();
        console.log('Map size invalidated again');
      }, 500);

      try {
        console.log('About to create satellite layer');
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          attribution: 'Basemap © Esri — Sources: Esri, i-cubed, USDA, USGS, AeroGRID, IGN, IGP'
        }).addTo(map);
        const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        });
        L.control.layers({ 'Satellite': satellite, 'Streets': streets }, null, { collapsed: true }).addTo(map);
        console.log('Layers created successfully');
      } catch (error) {
        console.error('Error creating layers:', error);
      }

      console.log('Creating cluster groups');
      const clusterGroups = {
        airport: L.markerClusterGroup({ disableClusteringAtZoom: 10 }),
        harbour: L.markerClusterGroup({ disableClusteringAtZoom: 10 }),
        energy: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
        rail: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
        border: L.markerClusterGroup({ disableClusteringAtZoom: 8 }),
        military: L.markerClusterGroup({ disableClusteringAtZoom: 8 })
      };
      Object.values(clusterGroups).forEach(group => map.addLayer(group));
      console.log('Cluster groups created');

      // Risk rings layer group
      const riskRings = L.layerGroup().addTo(map);

      // Threat heatmap layer group
      const threatHeatmap = L.layerGroup();

      const state = {
        data: { generated_utc: null, incidents: [] },
        markers: new Map(),
        showRiskRings: true,
        showThreatHeatmap: false,
        compareMode: false,
        hasAutoFocused: false,
        autoFocusEnabled: true,
        liveIncidents: new Set(),
        activityIndicatorVisible: false,
        allIncidents: [], // Track all incidents for mobile access
        dataLoaded: false // Flag to track if initial data has been loaded
      };
      console.log('State object created');

      // Make state globally accessible for mobile handlers
      window.state = state;
      window.droneState = state;
      console.log('State assigned to window:', !!window.state, !!window.droneState);

      // URL state management for shareable links
            function saveStateToURL() {
        const params = new URLSearchParams();

        const range = document.getElementById('dateRange');
        if (range) {
          params.set('days', range.value);
        }

        ['airport', 'harbour', 'energy', 'rail', 'border', 'military'].forEach(layer => {
          const el = document.getElementById(`layer-${layer}`);
          if (el && el.checked) {
            params.append('layers', layer);
          }
        });

        const statusSelect = document.getElementById('statusSelect');
        if (statusSelect) {
          Array.from(statusSelect.selectedOptions).forEach(opt => params.append('status', opt.value));
        }

        const evidenceSelect = document.getElementById('evidenceSelect');
        if (evidenceSelect) {
          Array.from(evidenceSelect.selectedOptions).forEach(opt => params.append('evidence', opt.value));
        }

        const searchInput = document.getElementById('searchBox');
        const searchTerm = searchInput ? searchInput.value.trim() : '';
        if (searchTerm) params.set('search', searchTerm);

        if (state.showRiskRings) params.set('risks', '1');
        if (state.compareMode) params.set('compare', '1');
        if (!state.autoFocusEnabled) params.set('noautofocus', '1');

        if (typeof map !== 'undefined') {
          const center = map.getCenter();
          const zoom = map.getZoom();
          params.set('lat', center.lat.toFixed(4));
          params.set('lng', center.lng.toFixed(4));
          params.set('zoom', zoom);
        }

        const newUrl = window.location.pathname + '?' + params.toString();
        window.history.replaceState({}, '', newUrl);
      }



        function loadStateFromURL() {
      const params = new URLSearchParams(window.location.search);

      if (params.has('days')) {
        const days = params.get('days');
        const range = document.getElementById('dateRange');
        if (range) {
          range.value = days;
        }
        const label = document.getElementById('dateRangeLabel');
        if (label) {
          label.textContent = `Showing last ${days} days`;
        }
        document.querySelectorAll('.chip[data-window]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.window === days);
        });
      }

      const layers = params.getAll('layers');
      if (layers.length > 0) {
        ['airport', 'harbour', 'energy', 'rail', 'border', 'military'].forEach(layer => {
          const el = document.getElementById(`layer-${layer}`);
          if (el) {
            el.checked = layers.includes(layer);
          }
        });
      }

      const statuses = params.getAll('status');
      if (statuses.length > 0) {
        const statusSelect = document.getElementById('statusSelect');
        if (statusSelect) {
          Array.from(statusSelect.options).forEach(opt => {
            opt.selected = statuses.includes(opt.value);
          });
        }
      }

      const evidences = params.getAll('evidence');
      if (evidences.length > 0) {
        const evidenceSelect = document.getElementById('evidenceSelect');
        if (evidenceSelect) {
          Array.from(evidenceSelect.options).forEach(opt => {
            opt.selected = evidences.includes(opt.value);
          });
        }
      }

      if (params.has('search')) {
        const searchInput = document.getElementById('searchBox');
        if (searchInput) {
          searchInput.value = params.get('search');
        }
      }

      if (params.has('risks')) {
        state.showRiskRings = params.get('risks') === '1';
        const riskToggle = document.getElementById('show-risk-rings');
        if (riskToggle) {
          riskToggle.checked = state.showRiskRings;
        }
      }

      if (params.has('compare')) {
        state.compareMode = params.get('compare') === '1';
        const compareToggle = document.getElementById('compare-mode');
        if (compareToggle) {
          compareToggle.checked = state.compareMode;
        }
        const compareControls = document.getElementById('compare-controls');
        if (compareControls) {
          compareControls.style.display = state.compareMode ? 'block' : 'none';
        }
      }

      if (params.has('noautofocus')) {
        state.autoFocusEnabled = false;
        const autoFocusToggle = document.getElementById('auto-focus');
        if (autoFocusToggle) {
          autoFocusToggle.checked = false;
        }
      }

      if (params.has('lat') && params.has('lng') && params.has('zoom') && typeof map !== 'undefined') {
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const zoom = parseInt(params.get('zoom'), 10);
        if (!Number.isNaN(lat) && !Number.isNaN(lng) && !Number.isNaN(zoom)) {
          map.setView([lat, lng], zoom);
        }
      }
    }



    function sevBox(score) {
      const level = Math.min(5, Math.max(1, Number(score) || 1));
      return `<span class="sev s${level}"></span>`;
    }

    function markerIcon(color, severity, isPrevious = false) {
      const size = 10 + (Number(severity) || 1) * 2;
      const borderStyle = isPrevious ? '2px dashed rgba(15,17,25,0.85)' : '2px solid rgba(15,17,25,0.85)';
      const opacity = isPrevious ? '0.7' : '1';
      return L.divIcon({
        html: `<div style="width:${size}px;height:${size}px;border-radius:50%;background:${color.trim()};border:${borderStyle};box-shadow:0 0 0 1px rgba(0,0,0,.35);opacity:${opacity};"></div>`,
        className: '',
        iconSize: [size, size]
      });
    }

    function fmtDate(value) {
      if (!value) return '—';
      try {
        return new Date(value).toISOString().slice(0, 16).replace('T', ' ');
      } catch (err) {
        return value;
      }
    }

    function fmtDuration(minutes) {
      if (minutes == null) return '—';
      if (minutes < 60) return `${minutes} min`;
      return `${(minutes / 60).toFixed(1)} h`;
    }

    function activeDays() {
      return parseInt(document.getElementById('dateRange').value, 10) || 365;
    }

    function selectedValues(select) {
      const opts = Array.from(select.selectedOptions).map(opt => opt.value);
      return opts.length ? opts : Array.from(select.options).map(opt => opt.value);
    }

        function assetToggles() {
      const layerToggles = {};
      let hasLayerToggle = false;
      ['airport', 'harbour', 'energy', 'rail', 'border', 'military'].forEach(layer => {
        const el = document.getElementById(`layer-${layer}`);
        if (el) {
          layerToggles[layer] = el.checked;
          hasLayerToggle = true;
        }
      });

      if (hasLayerToggle) {
        return layerToggles;
      }

      const airportEl = document.getElementById('filter-near-airports');
      const harbourEl = document.getElementById('filter-near-harbours');
      const militaryEl = document.getElementById('filter-near-military');

      return {
        airport: airportEl ? airportEl.checked : true,
        harbour: harbourEl ? harbourEl.checked : true,
        energy: true,
        rail: true,
        border: true,
        military: militaryEl ? militaryEl.checked : true
      };
    }



    function mapAssetType(assetType) {
      // Map asset types to filter categories
      if (assetType === 'nuclear') return 'energy';
      return assetType;
    }

    function searchTerm() {
      return document.getElementById('searchBox').value.trim().toLowerCase();
    }

    function filterIncidents(period = 'current') {
      const days = activeDays();
      let cutoffStart, cutoffEnd;

      if (state.compareMode && period === 'previous') {
        // Previous period: (2 * days) ago to (days) ago
        cutoffEnd = Date.now() - days * 24 * 3600 * 1000;
        cutoffStart = Date.now() - 2 * days * 24 * 3600 * 1000;
      } else {
        // Current period: (days) ago to now
        cutoffEnd = Date.now();
        cutoffStart = Date.now() - days * 24 * 3600 * 1000;
      }

      const statuses = new Set(selectedValues(document.getElementById('statusSelect')));
      const evidences = new Set(selectedValues(document.getElementById('evidenceSelect')));
      const query = searchTerm();

      return state.data.incidents.filter(item => {
        const seenTs = Date.parse(item.first_seen_utc || item.last_update_utc || state.data.generated_utc || Date.now());

        if (!Number.isFinite(seenTs)) {
          console.log('Filter rejected: invalid timestamp for', item.id);
          return false;
        }
        if (seenTs < cutoffStart || seenTs > cutoffEnd) {
          console.log('Filter rejected: date out of range for', item.id, 'Date:', new Date(seenTs).toISOString());
          return false;
        }
        if (!statuses.has(item.incident.status)) {
          console.log('Filter rejected: status not selected for', item.id, 'Status:', item.incident.status, 'Selected:', Array.from(statuses));
          return false;
        }
        if (!evidences.has(String(item.evidence.strength))) {
          console.log('Filter rejected: evidence not selected for', item.id, 'Evidence:', item.evidence.strength, 'Selected:', Array.from(evidences));
          return false;
        }
        if (query) {
          const haystack = [
            item.asset.name,
            item.asset.iata,
            item.asset.icao,
            item.incident.narrative,
            ...(item.evidence.sources || []).map(src => src.publisher)
          ].join(' ').toLowerCase();
          if (!haystack.includes(query)) return false;
        }

        // Check proximity filters
        const nearHarboursFilter = document.getElementById('filter-near-harbours');
        const nearMilitaryFilter = document.getElementById('filter-near-military');
        const nearAirportsFilter = document.getElementById('filter-near-airports');

        // If any proximity filter is active, check if incident matches
        const anyProximityFilterActive = (nearHarboursFilter && nearHarboursFilter.checked) ||
                                       (nearMilitaryFilter && nearMilitaryFilter.checked) ||
                                       (nearAirportsFilter && nearAirportsFilter.checked);

        if (anyProximityFilterActive) {
          let matchesProximityFilter = false;

          if (nearHarboursFilter && nearHarboursFilter.checked && isIncidentNearInfrastructure(item, 'harbours')) {
            matchesProximityFilter = true;
          }
          if (nearMilitaryFilter && nearMilitaryFilter.checked && isIncidentNearInfrastructure(item, 'military')) {
            matchesProximityFilter = true;
          }
          if (nearAirportsFilter && nearAirportsFilter.checked && isIncidentNearInfrastructure(item, 'airports')) {
            matchesProximityFilter = true;
          }

          if (!matchesProximityFilter) return false;
        }

        return true;
      });
    }

    // Global infrastructure data for proximity filtering
    let infrastructureData = {
      harbours: [],
      military: [],
      airports: []
    };

    // Calculate distance between two coordinates using Haversine formula
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Check if incident is near infrastructure (within 10km)
    function isIncidentNearInfrastructure(incident, infrastructureType) {
      if (!infrastructureData[infrastructureType] || infrastructureData[infrastructureType].length === 0) {
        return false;
      }

      const incidentLat = incident.asset.latitude;
      const incidentLng = incident.asset.longitude;

      if (!incidentLat || !incidentLng) return false;

      return infrastructureData[infrastructureType].some(item => {
        const distance = calculateDistance(incidentLat, incidentLng, item.lat, item.lng);
        return distance <= 10; // Within 10km
      });
    }

    // Load infrastructure data for proximity filtering
    async function loadInfrastructureDataForFiltering() {
      console.log('Loading infrastructure data for proximity filtering...');

      const infrastructureTypes = [
        { name: 'harbours', file: 'harbours.geojson' },
        { name: 'military', file: 'military.geojson' },
        { name: 'airports', file: 'airports_wikidata.geojson' }
      ];

      for (const infraType of infrastructureTypes) {
        try {
          console.log(`Loading ${infraType.name}...`);
          const response = await fetch(`./data/assets/${infraType.file}`);
          if (!response.ok) {
            console.warn(`Failed to load ${infraType.file}: ${response.status}`);
            continue;
          }

          const geojson = await response.json();
          infrastructureData[infraType.name] = geojson.features.map(feature => {
            const coords = feature.geometry.coordinates;
            return {
              lat: coords[1],
              lng: coords[0],
              name: feature.properties.name || 'Unknown',
              type: feature.properties.asset_type || infraType.name
            };
          });

          console.log(`Loaded ${infrastructureData[infraType.name].length} ${infraType.name} for proximity filtering`);
        } catch (error) {
          console.warn(`Error loading ${infraType.file}:`, error);
          infrastructureData[infraType.name] = [];
        }
      }
    }

    function popupHtml(incident) {
      const srcLinks = (incident.evidence.sources || []).slice(0, 2).map(src => {
        const label = src.publisher || 'source';
        return `<a href="${src.url}" target="_blank" rel="noopener">${label}</a>`;
      }).join(' · ');
      return `
        <strong>${incident.asset.name}${incident.asset.iata ? ` (${incident.asset.iata})` : ''}</strong><br />
        <b>Asset:</b> ${incident.asset.type} · ${sevBox(incident.scores.severity)} <b>Severity:</b> ${incident.scores.severity}<br />
        <b>Status:</b> ${incident.incident.status} · <b>Category:</b> ${incident.incident.category}<br />
        <b>Window:</b> ${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}<br />
        <b>Evidence:</b> ${incident.evidence.strength} · ${srcLinks || '<span class="muted">no link</span>'}<br />
        <div style="text-align: center; margin-top: 8px;">
          <button class="popup-provenance-btn" style="background: var(--focus); color: #fff; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 11px;">
            📋 Full Provenance
          </button>
        </div>
      `;
    }

    function showLoadingSkeletons() {
      const list = document.getElementById('incidentList');
      let skeletonHTML = '';
      for (let i = 0; i < 5; i++) {
        skeletonHTML += `
          <div class="skeleton skeleton-card">
            <div class="skeleton-title"></div>
            <div class="skeleton-line long"></div>
            <div class="skeleton-line short"></div>
          </div>
        `;
      }
      list.innerHTML = skeletonHTML;
    }

    function renderDetails(currentIncidents, previousIncidents = []) {
      const list = document.getElementById('incidentList');
      const intro = document.getElementById('detailsIntro');
      const noDataMessage = document.getElementById('noDataMessage');

      console.log('renderDetails called with', currentIncidents.length, 'current and', previousIncidents.length, 'previous incidents');

      // Show loading skeletons briefly for smooth transition
      if (list.innerHTML === '' || list.querySelector('.skeleton')) {
        showLoadingSkeletons();
        setTimeout(() => {
          renderDetailsContent(currentIncidents, previousIncidents);
        }, 300);
        return;
      }

      renderDetailsContent(currentIncidents, previousIncidents);
    }

    function renderDetailsContent(currentIncidents, previousIncidents = []) {
      const list = document.getElementById('incidentList');
      const intro = document.getElementById('detailsIntro');
      const noDataMessage = document.getElementById('noDataMessage');

      list.innerHTML = '';

      const totalCurrent = currentIncidents.length;
      const totalPrevious = previousIncidents.length;

      if (!totalCurrent && !totalPrevious) {
        console.log('Showing NO DATA message');
        intro.style.display = 'none';
        noDataMessage.style.display = 'block';
        return;
      }

      intro.style.display = 'block';
      noDataMessage.style.display = 'none';

      if (state.compareMode) {
        intro.innerHTML = `Current period: <strong>${totalCurrent}</strong> incidents | Previous period: <strong>${totalPrevious}</strong> incidents`;
      } else {
        intro.textContent = 'Most recent incidents. Click to focus on the map.';
      }

      // Show current period incidents
      const currentSorted = currentIncidents.sort((a, b) => Date.parse(b.first_seen_utc) - Date.parse(a.first_seen_utc));
      currentSorted.slice(0, state.compareMode ? 6 : 12).forEach(incident => {
        const card = document.createElement('div');
        card.className = 'incident';
        card.innerHTML = `
          <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
            <strong>${incident.asset.name}</strong>
            <div style="display: flex; gap: 8px; align-items: center;">
              <span class="muted">${incident.asset.type}</span>
              <button class="provenance-btn" style="background: var(--chip); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; color: var(--focus); cursor: pointer; font-size: 11px;">📋 Info</button>
            </div>
          </div>
          <div class="muted" style="margin:6px 0">${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}</div>
          <div>Category: <b>${incident.incident.category}</b> • Status: <b>${incident.incident.status}</b> • Evidence: <b>${incident.evidence.strength}</b> • Severity: <b>${incident.scores.severity}</b></div>
          <div class="muted" style="margin:6px 0">${incident.incident.narrative || ''}</div>
          <div>Sources: ${(incident.evidence.sources || []).map(src => `<a href="${src.url}" target="_blank" rel="noopener">${src.publisher || 'source'}</a>`).join(' · ') || '<span class="muted">—</span>'}</div>
        `;
        card.addEventListener('click', (e) => {
          if (e.target.classList.contains('provenance-btn')) {
            e.stopPropagation();
            showProvenance(incident);
          } else {
            focusIncident(incident);
          }
        });
        list.appendChild(card);
      });

      // Show previous period incidents if in compare mode
      if (state.compareMode && previousIncidents.length > 0) {
        const separator = document.createElement('div');
        separator.style.cssText = 'margin: 16px 0; padding: 8px 0; border-top: 1px solid var(--border); color: var(--severity-2); font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em;';
        separator.textContent = 'Previous Period';
        list.appendChild(separator);

        const previousSorted = previousIncidents.sort((a, b) => Date.parse(b.first_seen_utc) - Date.parse(a.first_seen_utc));
        previousSorted.slice(0, 6).forEach(incident => {
          const card = document.createElement('div');
          card.className = 'incident';
          card.style.borderColor = 'var(--severity-2)';
          card.style.opacity = '0.8';
          card.innerHTML = `
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:center;">
              <strong>${incident.asset.name}</strong>
              <div style="display: flex; gap: 8px; align-items: center;">
                <span class="muted">${incident.asset.type}</span>
                <button class="provenance-btn" style="background: var(--chip); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; color: var(--focus); cursor: pointer; font-size: 11px;">📋 Info</button>
              </div>
            </div>
            <div class="muted" style="margin:6px 0">${fmtDate(incident.first_seen_utc)} → ${fmtDate(incident.last_update_utc)}</div>
            <div>Category: <b>${incident.incident.category}</b> • Status: <b>${incident.incident.status}</b> • Evidence: <b>${incident.evidence.strength}</b> • Severity: <b>${incident.scores.severity}</b></div>
            <div class="muted" style="margin:6px 0">${incident.incident.narrative || ''}</div>
            <div>Sources: ${(incident.evidence.sources || []).map(src => `<a href="${src.url}" target="_blank" rel="noopener">${src.publisher || 'source'}</a>`).join(' · ') || '<span class="muted">—</span>'}</div>
          `;
          card.addEventListener('click', (e) => {
            if (e.target.classList.contains('provenance-btn')) {
              e.stopPropagation();
              showProvenance(incident);
            } else {
              focusIncident(incident);
            }
          });
          list.appendChild(card);
        });
      }
    }

    function focusIncident(incident) {
      const marker = window.state.markers.get(incident.id);
      if (!marker) return;

      // Close mobile bottom sheet if open
      const bottomSheet = document.getElementById('mobile-bottom-sheet');
      if (bottomSheet && bottomSheet.classList.contains('open')) {
        bottomSheet.classList.remove('open');
      }

      // Set mobile nav back to map tab
      const mapTab = document.querySelector('.mobile-nav-item[data-tab="map"]');
      const allTabs = document.querySelectorAll('.mobile-nav-item');
      if (mapTab && allTabs) {
        allTabs.forEach(tab => tab.classList.remove('active'));
        mapTab.classList.add('active');
      }

      // Pan to incident location with animation
      window.map.flyTo(marker.getLatLng(), Math.max(window.map.getZoom(), 8), {
        duration: 1.5,
        easeLinearity: 0.25
      });

      // Open popup after a short delay to ensure map has moved
      setTimeout(() => {
        marker.openPopup();
      }, 1500);
    }

    // Make focusIncident globally accessible for mobile handlers
    window.focusIncident = focusIncident;
    window.droneFocusIncident = focusIncident;
    console.log('FocusIncident assigned to window:', !!window.focusIncident, !!window.droneFocusIncident);

    function showProvenance(incident) {
      const modal = document.getElementById('provenanceModal');
      const content = document.getElementById('provenanceContent');

      // Calculate decision factors
      const evidenceLevel = incident.evidence.strength;
      const severityScore = incident.scores.severity;
      const statusClass = incident.incident.status === 'active' ? 'severity-4' : 'muted';

      // Format sources with credibility indicators
      const sourcesList = (incident.evidence.sources || []).map((source, idx) => {
        const tier1Sources = ['Reuters', 'AP', 'BBC', 'DR Nyheder', 'NRK', 'SVT Nyheter', 'Swedavia (Official)'];
        const tier2Sources = ['TV 2 Lorry', 'The Local Sweden', 'The Local Denmark'];
        const publisherClass = tier1Sources.includes(source.publisher) ? 'severity-3' :
                              tier2Sources.includes(source.publisher) ? 'severity-2' : 'muted';
        return `
          <div style="border: 1px solid var(--border); border-radius: 8px; padding: 12px; margin: 8px 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <strong style="color: var(--${publisherClass});">${source.publisher || 'Unknown Source'}</strong>
              <span class="muted" style="font-size: 11px;">${source.lang?.toUpperCase() || 'EN'}</span>
            </div>
            <div class="muted" style="font-size: 12px; margin-bottom: 8px;">
              First seen: ${fmtDate(source.first_seen)}
            </div>
            <a href="${source.url}" target="_blank" rel="noopener" style="color: var(--focus); text-decoration: none; font-size: 12px;">
              View source →
            </a>
          </div>
        `;
      }).join('');

      // Decision logic explanation
      const decisionFactors = [];
      if (evidenceLevel >= 3) decisionFactors.push('✓ Official/NOTAM confirmation');
      else if (evidenceLevel >= 2) decisionFactors.push('✓ Multiple credible sources');
      else if (evidenceLevel >= 1) decisionFactors.push('⚠ Single source verification');
      else decisionFactors.push('❌ Unverified reports');

      if (severityScore >= 4) decisionFactors.push('🔴 High operational impact');
      else if (severityScore >= 3) decisionFactors.push('🟡 Moderate impact');
      else decisionFactors.push('🟢 Low impact');

      if (incident.incident.status === 'active') decisionFactors.push('🚨 Currently active');
      if (incident.incident.response?.length) decisionFactors.push(`👮 Response: ${incident.incident.response.join(', ')}`);

      content.innerHTML = `
        <div class="provenance-section">
          <h3>${incident.asset.name}</h3>
          <div class="provenance-badges">
            <span class="badge" style="background: var(--${statusClass}); color: #fff;">${incident.incident.status.toUpperCase()}</span>
            <span class="badge" style="background: var(--chip); color: var(--text);">Evidence: ${evidenceLevel}/3</span>
            <span class="badge" style="background: var(--chip); color: var(--text);">Severity: ${severityScore}/5</span>
          </div>
          <div class="muted provenance-narrative">
            ${incident.incident.narrative || 'No additional details available.'}
          </div>
        </div>

        <div class="provenance-section">
          <h4>Decision Factors</h4>
          <div class="provenance-factors">
            ${decisionFactors.map(factor => `<div class="provenance-factor">${factor}</div>`).join('')}
          </div>
        </div>

        <div class="provenance-section">
          <h4>Timeline</h4>
          <div class="provenance-timeline">
            <div class="timeline-item">
              <span class="timeline-label">First detected:</span>
              <span class="timeline-value">${fmtDate(incident.first_seen_utc)}</span>
            </div>
            <div class="timeline-item">
              <span class="timeline-label">Last updated:</span>
              <span class="timeline-value">${fmtDate(incident.last_update_utc)}</span>
            </div>
            ${incident.incident.duration_min ? `
            <div class="timeline-item">
              <span class="timeline-label">Duration:</span>
              <span class="timeline-value">${fmtDuration(incident.incident.duration_min)}</span>
            </div>` : ''}
          </div>
        </div>

        <div class="provenance-section">
          <h4>Asset Information</h4>
          <div class="provenance-asset">
            <div class="asset-item">
              <span class="asset-label">Type:</span>
              <span class="asset-value">${incident.asset.type}</span>
            </div>
            ${incident.asset.iata ? `
            <div class="asset-item">
              <span class="asset-label">IATA:</span>
              <span class="asset-value">${incident.asset.iata}</span>
            </div>` : ''}
            ${incident.asset.icao ? `
            <div class="asset-item">
              <span class="asset-label">ICAO:</span>
              <span class="asset-value">${incident.asset.icao}</span>
            </div>` : ''}
            <div class="asset-item">
              <span class="asset-label">Coordinates:</span>
              <span class="asset-value">${incident.asset.lat.toFixed(4)}, ${incident.asset.lon.toFixed(4)}</span>
            </div>
            ${incident.scores.risk_radius_m ? `
            <div class="asset-item">
              <span class="asset-label">Risk radius:</span>
              <span class="asset-value">${(incident.scores.risk_radius_m/1000).toFixed(1)}km</span>
            </div>` : ''}
          </div>
        </div>

        <div class="provenance-section">
          <h4>Sources (${incident.evidence.sources?.length || 0})</h4>
          ${sourcesList || '<div class="muted">No sources available</div>'}
        </div>
      `;

      modal.style.display = 'block';
    }

    function hideProvenance() {
      document.getElementById('provenanceModal').style.display = 'none';
    }

    function renderRiskRings() {
      riskRings.clearLayers();
      if (!state.showRiskRings) return;

      const toggles = assetToggles();
      const processedAssets = new Set();

      state.data.incidents.forEach(incident => {
        const asset = incident.asset;
        const assetKey = `${asset.type}-${asset.lat}-${asset.lon}`;
        const mappedType = mapAssetType(asset.type);

        if (processedAssets.has(assetKey) || !toggles[mappedType]) return;
        processedAssets.add(assetKey);

        // Risk ring sizes based on asset type
        const ringConfig = {
          airport: { inner: 2000, outer: 5000, color: '#ef4444' },
          harbour: { inner: 1000, outer: 3000, color: '#3b82f6' },
          energy: { inner: 1500, outer: 4000, color: '#f97316' },
          rail: { inner: 800, outer: 2000, color: '#22c55e' },
          border: { inner: 500, outer: 1500, color: '#eab308' },
          military: { inner: 3000, outer: 8000, color: '#c084fc' }
        };

        const config = ringConfig[mappedType];
        if (!config) return;

        // Outer ring (restricted zone)
        const outerRing = L.circle([asset.lat, asset.lon], {
          radius: config.outer,
          fillColor: config.color,
          fillOpacity: 0.08,
          color: config.color,
          weight: 1,
          opacity: 0.3,
          dashArray: '5, 5'
        });

        // Inner ring (critical zone)
        const innerRing = L.circle([asset.lat, asset.lon], {
          radius: config.inner,
          fillColor: config.color,
          fillOpacity: 0.15,
          color: config.color,
          weight: 2,
          opacity: 0.5
        });

        outerRing.bindTooltip(`${asset.name}<br/>Restricted zone: ${(config.outer/1000)}km`, {
          permanent: false,
          className: 'risk-tooltip'
        });

        innerRing.bindTooltip(`${asset.name}<br/>Critical zone: ${(config.inner/1000)}km`, {
          permanent: false,
          className: 'risk-tooltip'
        });

        riskRings.addLayer(outerRing);
        riskRings.addLayer(innerRing);
      });
    }

    function renderThreatHeatmap() {
      threatHeatmap.clearLayers();

      if (!state.showThreatHeatmap) {
        if (map.hasLayer(threatHeatmap)) {
          map.removeLayer(threatHeatmap);
        }
        return;
      }

      if (!map.hasLayer(threatHeatmap)) {
        map.addLayer(threatHeatmap);
      }

      const filtered = filterIncidents('current');
      if (filtered.length === 0) return;

      // Create grid-based threat analysis
      const gridSize = 50000; // 50km grid cells
      const threatGrid = new Map();

      // Group incidents by geographic grid cells
      filtered.forEach(incident => {
        const lat = incident.asset.lat;
        const lon = incident.asset.lon;

        // Calculate grid cell
        const gridLat = Math.floor(lat * 1000 / (gridSize / 111320)) * (gridSize / 111320) / 1000;
        const gridLon = Math.floor(lon * 1000 / (gridSize / (111320 * Math.cos(lat * Math.PI / 180)))) * (gridSize / (111320 * Math.cos(lat * Math.PI / 180))) / 1000;
        const gridKey = `${gridLat},${gridLon}`;

        if (!threatGrid.has(gridKey)) {
          threatGrid.set(gridKey, {
            lat: gridLat,
            lon: gridLon,
            incidents: [],
            totalSeverity: 0,
            maxSeverity: 0,
            recentIncidents: 0
          });
        }

        const cell = threatGrid.get(gridKey);
        cell.incidents.push(incident);
        cell.totalSeverity += incident.scores.severity || 1;
        cell.maxSeverity = Math.max(cell.maxSeverity, incident.scores.severity || 1);

        // Count recent incidents (last 24 hours)
        const incidentTime = new Date(incident.first_seen_utc);
        const dayAgo = Date.now() - 24 * 60 * 60 * 1000;
        if (incidentTime > dayAgo) {
          cell.recentIncidents++;
        }
      });

      // Create heatmap circles for each grid cell
      threatGrid.forEach(cell => {
        const incidentCount = cell.incidents.length;
        if (incidentCount === 0) return;

        // Calculate threat level (0-1)
        const density = incidentCount / 10; // Normalize by expected max incidents per cell
        const severity = cell.totalSeverity / incidentCount; // Average severity
        const recency = cell.recentIncidents / incidentCount; // Recent activity ratio

        const threatLevel = Math.min(1, (density * 0.4 + severity / 5 * 0.4 + recency * 0.2));

        // Determine colors based on threat level
        const color = threatLevel > 0.7 ? '#dc2626' : // High threat - red
                     threatLevel > 0.5 ? '#ea580c' : // Medium-high threat - orange
                     threatLevel > 0.3 ? '#f59e0b' : // Medium threat - yellow
                     '#3b82f6'; // Low threat - blue

        const opacity = Math.max(0.1, threatLevel * 0.6);
        const radius = Math.max(15000, threatLevel * 40000); // 15-40km radius

        // Create heatmap circle
        const circle = L.circle([cell.lat, cell.lon], {
          radius: radius,
          fillColor: color,
          fillOpacity: opacity,
          color: color,
          weight: 1,
          opacity: opacity * 1.5
        });

        // Create tooltip with threat information
        const tooltipContent = `
          <div style="font-size: 12px; line-height: 1.4;">
            <strong>Threat Level: ${Math.round(threatLevel * 100)}%</strong><br>
            ${incidentCount} incident${incidentCount > 1 ? 's' : ''}<br>
            Avg Severity: ${(cell.totalSeverity / incidentCount).toFixed(1)}<br>
            ${cell.recentIncidents} recent (24h)<br>
            Max Severity: ${cell.maxSeverity}
          </div>
        `;

        circle.bindTooltip(tooltipContent, {
          permanent: false,
          className: 'risk-tooltip'
        });

        threatHeatmap.addLayer(circle);
      });

      console.log(`Rendered threat heatmap with ${threatGrid.size} grid cells`);
    }

    function updateStatistics(incidents) {
      const now = new Date();
      const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
      const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

      // Active incidents
      const activeCount = incidents.filter(i => i.incident.status === 'active').length;
      document.getElementById('stat-active').textContent = activeCount;

      // 24h incidents
      const last24h = incidents.filter(i => new Date(i.first_seen_utc) >= twentyFourHoursAgo).length;
      document.getElementById('stat-24h').textContent = last24h;

      // High severity (4-5)
      const highSeverity = incidents.filter(i => i.scores.severity >= 4).length;
      document.getElementById('stat-severity').textContent = highSeverity;
      const severityPercentage = incidents.length > 0 ? (highSeverity / incidents.length) * 100 : 0;
      document.getElementById('severity-bar').style.width = severityPercentage + '%';

      // Assets affected
      const uniqueAssets = new Set(incidents.map(i => i.asset.name));
      document.getElementById('stat-assets').textContent = uniqueAssets.size;

      // Asset breakdown
      const assetTypes = {};
      incidents.forEach(i => {
        assetTypes[i.asset.type] = (assetTypes[i.asset.type] || 0) + 1;
      });
      const topType = Object.entries(assetTypes).sort((a, b) => b[1] - a[1])[0];
      if (topType) {
        document.getElementById('stat-assets-detail').textContent = `${topType[0]}: ${topType[1]}`;
      }

      // Calculate changes (compare to previous period)
      if (state.previousStats) {
        // Active change
        const activeChange = activeCount - state.previousStats.active;
        const activeEl = document.getElementById('stat-active-change');
        activeEl.textContent = Math.abs(activeChange) + ' vs prev';
        activeEl.className = activeChange > 0 ? 'stat-change positive' : activeChange < 0 ? 'stat-change negative' : 'stat-change neutral';

        // 24h change
        const change24h = last24h - state.previousStats.last24h;
        const el24h = document.getElementById('stat-24h-change');
        el24h.textContent = Math.abs(change24h) + ' vs yesterday';
        el24h.className = change24h > 0 ? 'stat-change positive' : change24h < 0 ? 'stat-change negative' : 'stat-change neutral';
      }

      // Draw trend chart
      drawTrendChart(incidents);

      // Store current stats for next comparison
      state.currentStats = {
        active: activeCount,
        last24h: last24h,
        highSeverity: highSeverity,
        assets: uniqueAssets.size
      };
    }

    function drawTrendChart(incidents) {
      const canvas = document.getElementById('trend-chart');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;

      // Clear canvas
      ctx.clearRect(0, 0, width, height);

      // Calculate daily counts for last 7 days
      const dailyCounts = [];
      for (let i = 6; i >= 0; i--) {
        const dayStart = new Date();
        dayStart.setDate(dayStart.getDate() - i);
        dayStart.setHours(0, 0, 0, 0);

        const dayEnd = new Date(dayStart);
        dayEnd.setDate(dayEnd.getDate() + 1);

        const count = incidents.filter(inc => {
          const incDate = new Date(inc.first_seen_utc);
          return incDate >= dayStart && incDate < dayEnd;
        }).length;

        dailyCounts.push(count);
      }

      // Find max for scaling
      const maxCount = Math.max(...dailyCounts, 1);

      // Draw chart
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent') + '20';
      ctx.lineWidth = 2;

      ctx.beginPath();
      dailyCounts.forEach((count, i) => {
        const x = (i / 6) * (width - 10) + 5;
        const y = height - (count / maxCount) * (height - 10) - 5;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      // Fill area under line
      ctx.lineTo(width - 5, height - 5);
      ctx.lineTo(5, height - 5);
      ctx.closePath();
      ctx.fill();

      // Draw line on top
      ctx.beginPath();
      dailyCounts.forEach((count, i) => {
        const x = (i / 6) * (width - 10) + 5;
        const y = height - (count / maxCount) * (height - 10) - 5;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();

      // Draw dots
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      dailyCounts.forEach((count, i) => {
        const x = (i / 6) * (width - 10) + 5;
        const y = height - (count / maxCount) * (height - 10) - 5;

        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function renderCriticalAlerts(incidents) {
      const container = document.getElementById('critical-alerts');
      if (!container) return;

      container.innerHTML = '';
      if (!Array.isArray(incidents) || incidents.length === 0) {
        container.innerHTML = '<p class="empty-state muted">No incidents in the current view.</p>';
        return;
      }

      const activeIncidents = incidents
        .filter(incident => incident.incident?.status === 'active')
        .sort((a, b) => {
          const severityDiff = (b.scores?.severity || 0) - (a.scores?.severity || 0);
          if (severityDiff !== 0) return severityDiff;
          const aTime = new Date(a.last_update_utc || a.first_seen_utc || 0).getTime();
          const bTime = new Date(b.last_update_utc || b.first_seen_utc || 0).getTime();
          return bTime - aTime;
        });

      if (activeIncidents.length === 0) {
        container.innerHTML = '<p class="empty-state muted">No active incidents at the moment.</p>';
        return;
      }

      activeIncidents.slice(0, 3).forEach(incident => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'critical-card';
        const severity = incident.scores?.severity || 0;
        const assetName = incident.asset?.name || 'Unidentified asset';
        const category = incident.incident?.category || 'incident';
        const time = getTimeAgo(new Date(incident.last_update_utc || incident.first_seen_utc || Date.now()));

        button.innerHTML = `
          <div class="critical-card__header">
            <span class="critical-dot severity-${severity}"></span>
            <span class="critical-asset">${assetName}</span>
            <span class="critical-time">${time}</span>
          </div>
          <div class="critical-meta">${category.replace(/_/g, ' ')} • Severity ${severity}</div>
        `;

        button.addEventListener('click', () => {
          renderDetails([incident]);
          if (typeof focusIncident === 'function') {
            focusIncident(incident);
          }
        });

        container.appendChild(button);
      });
    }

    function renderNewsBriefs(incidents) {
      const container = document.getElementById('news-feed');
      if (!container) return;

      container.innerHTML = '';
      if (!Array.isArray(incidents) || incidents.length === 0) {
        container.innerHTML = '<p class="empty-state muted">No recent intelligence updates.</p>';
        return;
      }

      const sorted = [...incidents]
        .sort((a, b) => {
          const aTime = new Date(a.last_update_utc || a.first_seen_utc || 0).getTime();
          const bTime = new Date(b.last_update_utc || b.first_seen_utc || 0).getTime();
          return bTime - aTime;
        })
        .slice(0, 4);

      sorted.forEach(incident => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'news-item';
        const assetName = incident.asset?.name || 'Unknown asset';
        const location = incident.asset?.location || incident.asset?.country || incident.asset?.region || 'Location withheld';
        const category = incident.incident?.category || 'incident';
        const status = incident.incident?.status || 'status unknown';
        const tag = incident.tags?.includes('ai-generated') ? 'AI Insight' : incident.tags?.[0];
        const time = getTimeAgo(new Date(incident.last_update_utc || incident.first_seen_utc || Date.now()));
        const severity = incident.scores?.severity || 0;

        item.innerHTML = `
          <div class="news-item__header">
            <span class="news-headline">${assetName}</span>
            <span class="news-meta">${time}</span>
          </div>
          <div class="news-body">${category.replace(/_/g, ' ')} • ${status.replace(/_/g, ' ')} • Severity ${severity}</div>
          <div class="news-footer">
            <span class="news-location">${location}</span>
            ${tag ? `<span class="news-tag">${tag}</span>` : ''}
          </div>
        `;

        item.addEventListener('click', () => {
          renderDetails([incident]);
          if (typeof focusIncident === 'function') {
            focusIncident(incident);
          }
        });

        container.appendChild(item);
      });
    }

    function render() {
      console.log('render() called, total incidents:', state.data.incidents.length);
      console.log('render() state.data:', state.data);

      // Safety check: don't render if no incident data loaded yet
      if (!state.dataLoaded) {
        console.log('render() called but data not loaded yet, skipping');
        return;
      }
      if (!state.data || !Array.isArray(state.data.incidents)) {
        console.log('render() called but incident data structure not ready yet, skipping');
        return;
      }

      // Add debugging for date filtering
      const days = activeDays();
      const cutoffStart = Date.now() - days * 24 * 3600 * 1000;
      const cutoffEnd = Date.now();
      console.log('Date filter debug:');
      console.log('- Days:', days);
      console.log('- Cutoff start:', new Date(cutoffStart).toISOString());
      console.log('- Cutoff end:', new Date(cutoffEnd).toISOString());
      console.log('- Now:', new Date().toISOString());

      Object.values(clusterGroups).forEach(group => group.clearLayers());
      state.markers.clear();

      // TEMPORARY: Use all incidents to test if filtering is the issue
      const currentFiltered = state.data.incidents; // filterIncidents('current');
      const previousFiltered = state.compareMode ? filterIncidents('previous') : [];

      console.log('Filtered incidents debug (BYPASSING FILTERS FOR TEST):');
      console.log('- Total available:', state.data.incidents.length);
      console.log('- After filtering:', currentFiltered.length);

      // Update statistics dashboard
      updateStatistics(currentFiltered);

      // Store all current incidents for mobile access
      state.allIncidents = currentFiltered;

      renderCriticalAlerts(currentFiltered);
      renderNewsBriefs(state.data.incidents);


      console.log('current period incidents:', currentFiltered.length);
      if (state.compareMode) console.log('previous period incidents:', previousFiltered.length);

      // Update status badge and map overlay
      const statusBadge = document.getElementById('badge-status');
      const mapOverlay = document.getElementById('mapOverlay');

      if (state.data.incidents.length === 0) {
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = 'NO DATA';
        mapOverlay.style.display = 'block';
      } else if (currentFiltered.length === 0 && previousFiltered.length === 0) {
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = 'NO MATCHES';
        mapOverlay.style.display = 'none';
      } else {
        statusBadge.style.display = 'none';
        mapOverlay.style.display = 'none';
      }

      const toggles = assetToggles();
      const mapMarkers = [];
      let countAir = 0;
      let countHar = 0;
      let countAirPrev = 0;
      let countHarPrev = 0;

      // Render current period incidents
      currentFiltered.forEach(incident => {
        const assetType = incident.asset.type;
        const mappedType = mapAssetType(assetType);
        if (!toggles[mappedType]) return;
        const color = assetColors[mappedType] || '#6ea8fe';
        const marker = L.marker([incident.asset.lat, incident.asset.lon], {
          icon: markerIcon(color, incident.scores.severity)
        }).bindPopup(popupHtml(incident));

        marker.incident = incident;
        marker.on('click', () => renderDetails([incident]));
        marker.on('popupopen', () => {
          const provenanceBtn = document.querySelector('.popup-provenance-btn');
          if (provenanceBtn) {
            provenanceBtn.addEventListener('click', () => showProvenance(marker.incident));
          }
        });

        state.markers.set(incident.id, marker);
        if (clusterGroups[mappedType]) {
          clusterGroups[mappedType].addLayer(marker);
        }
        mapMarkers.push(marker);

        // Add live animation if incident is live
        if (isLiveIncident(incident)) {
          // Add to live incidents set
          state.liveIncidents.add(incident.id);
          // Apply animation after marker is added to map
          setTimeout(() => addLiveMarkerAnimation(marker), 100);
        }

        if (mappedType === 'airport') countAir += 1;
        if (mappedType === 'harbour') countHar += 1;
      });

      // Render previous period incidents with different styling (if compare mode)
      if (state.compareMode) {
        previousFiltered.forEach(incident => {
          const assetType = incident.asset.type;
          const mappedType = mapAssetType(assetType);
          if (!toggles[mappedType]) return;
          const color = '#60a5fa'; // Blue for previous period
          const marker = L.marker([incident.asset.lat, incident.asset.lon], {
            icon: markerIcon(color, incident.scores.severity, true) // true = previous period
          }).bindPopup(`<div style="border-left: 3px solid #60a5fa; padding-left: 8px;"><strong>Previous Period</strong><br/>${popupHtml(incident)}</div>`);

          marker.incident = incident;
          marker.on('popupopen', () => {
            const provenanceBtn = document.querySelector('.popup-provenance-btn');
            if (provenanceBtn) {
              provenanceBtn.addEventListener('click', () => showProvenance(marker.incident));
            }
          });

          state.markers.set('prev-' + incident.id, marker);
          if (clusterGroups[mappedType]) {
            clusterGroups[mappedType].addLayer(marker);
          }
          mapMarkers.push(marker);
          if (mappedType === 'airport') countAirPrev += 1;
          if (mappedType === 'harbour') countHarPrev += 1;
        });
      }

      // Update statistics
      if (state.compareMode) {
        document.getElementById('stat-total').innerHTML = `${currentFiltered.length} <span class="muted">(vs ${previousFiltered.length})</span>`;
        document.getElementById('stat-air').innerHTML = `${countAir} <span class="muted">(vs ${countAirPrev})</span>`;
        document.getElementById('stat-har').innerHTML = `${countHar} <span class="muted">(vs ${countHarPrev})</span>`;
      } else {
        document.getElementById('stat-total').textContent = currentFiltered.length;
        document.getElementById('stat-air').textContent = countAir;
        document.getElementById('stat-har').textContent = countHar;
      }

      if (mapMarkers.length) {
        const group = L.featureGroup(mapMarkers);
        // Always fit bounds to show ALL incidents, with padding
        if (mapMarkers.length === 1) {
          // For single incident, use moderate zoom
          const incident = mapMarkers[0].incident;
          let zoomLevel = 7; // City level for single incident
          if (incident.scores.severity >= 4) zoomLevel = 8;
          if (incident.incident.status === 'active') zoomLevel = 9;
          map.setView(mapMarkers[0].getLatLng(), zoomLevel);
        } else {
          // For multiple incidents, fit bounds to show all
          map.fitBounds(group.getBounds().pad(0.2));
        }
        // Remove any existing no-data overlay
        if (map._noDataOverlay) {
          map.removeControl(map._noDataOverlay);
          map._noDataOverlay = null;
        }
      } else {
        // Show no data overlay on map if no markers to display
        if (!map._noDataOverlay) {
          map._noDataOverlay = L.control({ position: 'topright' });
          map._noDataOverlay.onAdd = function() {
            const div = L.DomUtil.create('div', 'no-data-overlay');
            div.style.cssText = 'padding: 20px 24px; border-radius: 12px; font-size: 18px; font-weight: 900; text-align: center; letter-spacing: 1px; min-width: 120px;';
            div.innerHTML = 'NO DATA';
            return div;
          };
          map.addControl(map._noDataOverlay);
        }
      }

      renderDetails(currentFiltered, previousFiltered);
      renderRiskRings();
      renderThreatHeatmap();

      // Update live activity after rendering
      updateLiveActivity();

      // Check for breaking news after rendering
      checkForBreakingNews();

      // Render activity timeline
      renderActivityTimeline();
    }

    async function fetchIncidents() {
      console.log('fetchIncidents() called, fetching from:', INCIDENTS_URL);

      // Show refresh indicator
      const refreshBadge = document.getElementById('badge-refresh');
      const originalText = refreshBadge.textContent;
      refreshBadge.textContent = '⟳ Updating...';
      refreshBadge.style.background = 'var(--focus)';

      try {
        const res = await fetch(`${INCIDENTS_URL}?_=${Date.now()}`, { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        console.log('fetchIncidents() received data:', data);
        console.log('fetchIncidents() incidents count:', data?.incidents?.length || 0);

        // Demo filtering disabled - now using real incident data
        state.data = data || { generated_utc: null, incidents: [] };
        state.dataLoaded = true; // Mark data as loaded
        console.log('fetchIncidents() after setting state.data.incidents.length:', state.data.incidents.length);
        document.getElementById('badge-generated').textContent = `Generated: ${new Date(state.data.generated_utc).toLocaleString() || '—'}`;

        // Show success indicator briefly
        refreshBadge.textContent = '✓ Updated';
        refreshBadge.style.background = 'var(--severity-3)';
        setTimeout(() => {
          refreshBadge.textContent = originalText;
          refreshBadge.style.background = '';
        }, 2000);

      } catch (err) {
        console.error('Failed to fetch incidents.json', err);
        // Set empty state on error
        state.data = { generated_utc: null, incidents: [] };
        document.getElementById('badge-generated').textContent = 'Generated: Failed to load';

        // Show error indicator
        refreshBadge.textContent = '⚠ Error';
        refreshBadge.style.background = 'var(--severity-4)';
        setTimeout(() => {
          refreshBadge.textContent = originalText;
          refreshBadge.style.background = '';
        }, 3000);
      }
    }

    // Live Activity Functions
    function isLiveIncident(incident) {
      const incidentTime = new Date(incident.first_seen_utc).getTime();
      const now = Date.now();
      const oneHour = 60 * 60 * 1000;

      // Incident is "live" if it occurred within the last hour
      return (now - incidentTime) <= oneHour;
    }

    function updateLiveActivity() {
      const currentLive = new Set();
      const now = Date.now();

      // Find all live incidents
      state.data.incidents.forEach(incident => {
        if (isLiveIncident(incident)) {
          currentLive.add(incident.id);
        }
      });

      // Update live incidents set
      const newLiveIncidents = [...currentLive].filter(id => !state.liveIncidents.has(id));
      const expiredLiveIncidents = [...state.liveIncidents].filter(id => !currentLive.has(id));

      state.liveIncidents = currentLive;

      // Update activity indicator
      updateActivityIndicator();

      // Add pulse animation to new live incident markers
      newLiveIncidents.forEach(incidentId => {
        const marker = state.markers.get(incidentId);
        if (marker && marker.getElement) {
          const element = marker.getElement();
          if (element) {
            element.classList.add('live-marker');
          }
        }
      });

      // Remove pulse animation from expired live incidents
      expiredLiveIncidents.forEach(incidentId => {
        const marker = state.markers.get(incidentId);
        if (marker && marker.getElement) {
          const element = marker.getElement();
          if (element) {
            element.classList.remove('live-marker');
          }
        }
      });

      console.log(`Live activity update: ${currentLive.size} active incidents`, {
        new: newLiveIncidents.length,
        expired: expiredLiveIncidents.length
      });
    }

    function updateActivityIndicator() {
      const indicator = document.getElementById('activity-indicator');
      const activityText = document.getElementById('activity-text');
      const liveCount = state.liveIncidents.size;

      if (liveCount > 0) {
        if (!state.activityIndicatorVisible) {
          indicator.classList.add('visible');
          state.activityIndicatorVisible = true;
        }

        activityText.textContent = liveCount === 1
          ? '1 Live Incident'
          : `${liveCount} Live Incidents`;
      } else {
        if (state.activityIndicatorVisible) {
          indicator.classList.remove('visible');
          state.activityIndicatorVisible = false;
        }
      }
    }

    function addLiveMarkerAnimation(marker) {
      if (marker.getElement) {
        const element = marker.getElement();
        if (element) {
          element.classList.add('live-marker');
        }
      }
    }

    // Breaking News Alert Functions
    let lastAlertTime = 0;
    let shownAlerts = new Set();

    function checkForBreakingNews() {
      const now = Date.now();
      const fifteenMinutes = 15 * 60 * 1000;

      // Find incidents that are less than 15 minutes old and not already shown
      const breakingIncidents = state.data.incidents.filter(incident => {
        const incidentTime = new Date(incident.first_seen_utc).getTime();
        const age = now - incidentTime;
        return age <= fifteenMinutes &&
               age >= 0 && // Not in the future
               !shownAlerts.has(incident.id) &&
               incident.scores?.severity >= 3; // Only show high severity incidents
      });

      if (breakingIncidents.length > 0) {
        // Sort by recency and severity, show the most significant
        const mostSignificant = breakingIncidents.sort((a, b) => {
          const aTime = new Date(a.first_seen_utc).getTime();
          const bTime = new Date(b.first_seen_utc).getTime();
          const aSeverity = a.scores?.severity || 1;
          const bSeverity = b.scores?.severity || 1;

          // Prioritize by severity first, then by recency
          if (bSeverity !== aSeverity) return bSeverity - aSeverity;
          return bTime - aTime;
        })[0];

        showBreakingNewsAlert(mostSignificant);
      }
    }

    function showBreakingNewsAlert(incident) {
      // Don't spam alerts - at least 2 minutes between alerts
      const now = Date.now();
      if (now - lastAlertTime < 120000) return;

      lastAlertTime = now;
      shownAlerts.add(incident.id);

      const alert = document.getElementById('breaking-news-alert');
      const title = document.getElementById('breaking-title');
      const details = document.getElementById('breaking-details');

      // Create breaking news content
      const assetName = incident.asset?.name || 'Unknown Location';
      const assetType = incident.asset?.type || 'facility';
      const timeAgo = getTimeAgo(new Date(incident.first_seen_utc));
      const severity = incident.scores?.severity || 1;

      title.textContent = `${assetType.charAt(0).toUpperCase() + assetType.slice(1)} Incident Detected`;
      details.innerHTML = `
        <strong>${assetName}</strong><br>
        Severity ${severity} • ${timeAgo} • Evidence: ${incident.evidence?.attribution || 'Unknown'}
      `;

      // Show alert with animation
      alert.classList.add('visible');

      // Play notification sound (if user has interacted with page)
      playNotificationSound();

      // Auto-hide after 8 seconds
      setTimeout(() => {
        hideBreakingNewsAlert();
      }, 8000);

      console.log('Breaking news alert shown for incident:', incident.id);
    }

    function hideBreakingNewsAlert() {
      const alert = document.getElementById('breaking-news-alert');
      alert.classList.remove('visible');
    }

    function playNotificationSound() {
      // Create a subtle notification sound using Web Audio API
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);

        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } catch (error) {
        console.log('Audio notification not available:', error.message);
      }
    }

    function getTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const minutes = Math.floor(diff / (1000 * 60));

      if (minutes < 1) return 'Just now';
      if (minutes === 1) return '1 minute ago';
      if (minutes < 60) return `${minutes} minutes ago`;

      const hours = Math.floor(minutes / 60);
      if (hours === 1) return '1 hour ago';
      return `${hours} hours ago`;
    }

    // Activity Timeline Functions
    function renderActivityTimeline() {
      const timeline = document.getElementById('activity-timeline');
      const filtered = filterIncidents('current');

      if (filtered.length === 0) {
        timeline.innerHTML = '<div class="timeline-empty">No incidents in selected time window</div>';
        return;
      }

      // Group incidents by hour
      const hourlyGroups = new Map();
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      // Initialize last 12 hours
      for (let i = 0; i < 12; i++) {
        const hour = new Date(now.getTime() - i * 60 * 60 * 1000);
        const key = `${hour.getDate()}-${hour.getHours()}`;
        hourlyGroups.set(key, {
          hour: hour,
          incidents: [],
          isToday: hour >= today
        });
      }

      // Group incidents by hour
      filtered.forEach(incident => {
        const incidentDate = new Date(incident.first_seen_utc);
        const key = `${incidentDate.getDate()}-${incidentDate.getHours()}`;

        if (hourlyGroups.has(key)) {
          hourlyGroups.get(key).incidents.push(incident);
        }
      });

      // Sort groups by time (most recent first)
      const sortedGroups = Array.from(hourlyGroups.values())
        .sort((a, b) => b.hour - a.hour);

      // Render timeline
      let html = '';
      for (const group of sortedGroups) {
        if (group.incidents.length === 0) continue;

        const hourLabel = group.isToday
          ? (group.hour.getHours() === now.getHours() ? 'This hour' : `${group.hour.getHours()}:00`)
          : group.hour.toLocaleDateString('en-GB', { month: 'short', day: 'numeric', hour: '2-digit' });

        html += `
          <div class="timeline-hour">
            <div class="timeline-hour-label">
              ${hourLabel}
              <span class="timeline-hour-count">${group.incidents.length}</span>
            </div>
            <div class="timeline-incidents">
        `;

        // Sort incidents within hour by time (most recent first)
        const sortedIncidents = group.incidents.sort((a, b) =>
          new Date(b.first_seen_utc) - new Date(a.first_seen_utc)
        );

        for (const incident of sortedIncidents) {
          const assetColor = assetColors[mapAssetType(incident.asset.type)] || '#6ea8fe';
          const assetName = incident.asset.name || 'Unknown Location';
          const time = new Date(incident.first_seen_utc);
          const timeStr = time.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
          const isLive = isLiveIncident(incident);

          html += `
            <div class="timeline-incident ${isLive ? 'live-incident' : ''}" data-incident-id="${incident.id}">
              <div class="timeline-incident-dot" style="background: ${assetColor};"></div>
              <div class="timeline-incident-info">
                <div class="timeline-incident-name" title="${assetName}">
                  ${assetName}
                  ${isLive ? ' 🔴' : ''}
                </div>
                <div class="timeline-incident-time">
                  ${timeStr} • Sev ${incident.scores?.severity || 1} • ${incident.evidence?.attribution || 'Unknown'}
                </div>
              </div>
            </div>
          `;
        }

        html += `
            </div>
          </div>
        `;
      }

      if (html === '') {
        timeline.innerHTML = '<div class="timeline-empty">No recent activity</div>';
      } else {
        timeline.innerHTML = html;

        // Add click handlers for timeline incidents
        timeline.querySelectorAll('.timeline-incident').forEach(element => {
          element.addEventListener('click', (e) => {
            const incidentId = e.currentTarget.getAttribute('data-incident-id');
            const incident = filtered.find(inc => inc.id === incidentId);
            if (incident) {
              focusIncident(incident);
            }
          });
        });
      }
    }

    function autoFocusOnRecentActivity() {
      // Don't auto-focus if disabled by user
      if (!state.autoFocusEnabled) {
        console.log('Auto-focus disabled by user');
        return;
      }

      // Don't auto-focus if user has manually set map position via URL
      const params = new URLSearchParams(window.location.search);
      if (params.has('lat') && params.has('lng')) {
        console.log('Manual map position detected, skipping auto-focus');
        return;
      }

      let targetIncidents = filterIncidents('current');

      // Fallback 1: If no current incidents, try active incidents from any time period
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents.filter(inc => inc.incident.status === 'active');
        console.log('No current incidents, trying active incidents:', targetIncidents.length);
      }

      // Fallback 2: If no active incidents, try high-severity incidents (4+)
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents.filter(inc => inc.scores.severity >= 4);
        console.log('No active incidents, trying high-severity incidents:', targetIncidents.length);
      }

      // Fallback 3: If still none, use all available incidents
      if (targetIncidents.length === 0) {
        targetIncidents = state.data.incidents;
        console.log('No high-severity incidents, using all incidents:', targetIncidents.length);
      }

      // Final fallback: If truly no data, stay with default European view
      if (targetIncidents.length === 0) {
        console.log('No incidents available for auto-focus, keeping default view');
        return;
      }

      // Find most recent incident from available pool
      const mostRecent = targetIncidents.reduce((latest, incident) => {
        const incidentTime = Date.parse(incident.first_seen_utc || incident.last_update_utc);
        const latestTime = Date.parse(latest.first_seen_utc || latest.last_update_utc);
        return incidentTime > latestTime ? incident : latest;
      });

      // Focus on the most recent incident with intelligent zoom level
      const focusLat = mostRecent.asset.lat;
      const focusLng = mostRecent.asset.lon;

      // Smart zoom based on priority factors - showing operational area, not street level
      let zoomLevel = 6; // Regional overview
      if (mostRecent.scores.severity >= 4) zoomLevel = 7; // High severity = city level
      if (mostRecent.incident.status === 'active') zoomLevel = Math.max(zoomLevel, 8); // Active = closer but still operational
      if (mostRecent.asset.type === 'airport') zoomLevel = Math.max(zoomLevel, 7); // Airports = show approaches
      if (Date.now() - Date.parse(mostRecent.first_seen_utc) < 24 * 3600 * 1000) zoomLevel += 0.5; // Recent = slightly closer

      console.log(`Auto-focusing on: ${mostRecent.asset.name} (${mostRecent.asset.type}) | Severity: ${mostRecent.scores.severity} | Status: ${mostRecent.incident.status} | Zoom: ${zoomLevel}`);

      // Smooth animation to the location
      map.flyTo([focusLat, focusLng], zoomLevel, {
        animate: true,
        duration: 2.0 // 2 second smooth animation
      });

      // Show a brief notification about the auto-focus
      showAutoFocusNotification(mostRecent);

      // Open popup after animation completes
      setTimeout(() => {
        const marker = state.markers.get(mostRecent.id);
        if (marker) {
          marker.openPopup();
          // Auto-close popup after 4 seconds
          setTimeout(() => marker.closePopup(), 4000);
        }
      }, 2500);
    }

    function showAutoFocusNotification(incident) {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--surface);
        border: 2px solid var(--focus);
        border-radius: 8px;
        padding: 12px 16px;
        color: var(--text);
        font-size: 14px;
        font-weight: 600;
        z-index: 1500;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        animation: slideInRight 0.3s ease-out forwards;
      `;

      const ageDays = Math.floor((Date.now() - Date.parse(incident.first_seen_utc)) / (24 * 3600 * 1000));
      const ageText = ageDays === 0 ? 'today' : ageDays === 1 ? 'yesterday' : `${ageDays} days ago`;

      notification.innerHTML = `
        📍 <strong>Focused on most recent activity</strong><br/>
        <span style="color: var(--muted); font-size: 12px; font-weight: normal;">
          ${incident.asset.name} • ${ageText}
        </span>
      `;

      document.body.appendChild(notification);

      // Remove notification after 5 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease-in forwards';
        setTimeout(() => document.body.removeChild(notification), 300);
      }, 5000);
    }

    async function refreshAll() {
      await fetchIncidents();
      render();

      // Auto-focus on first load only - but let render() handle the map view
      // The render() function now properly shows ALL incidents with fitBounds
      state.hasAutoFocused = true;
    }

    function setupUI() {
      const dateRange = document.getElementById('dateRange');
      const dateLabel = document.getElementById('dateRangeLabel');

      // Load state from URL on init
      loadStateFromURL();

      document.querySelectorAll('.chip[data-window]').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.chip[data-window]').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          dateRange.value = btn.dataset.window;
          dateLabel.textContent = `Showing last ${dateRange.value} days`;
          render();
          saveStateToURL();
        });
      });

      [
        dateRange,
        document.getElementById('statusSelect'),
        document.getElementById('evidenceSelect'),
        document.getElementById('show-risk-rings'),
        document.getElementById('show-threat-heatmap'),
        document.getElementById('compare-mode'),
        document.getElementById('auto-focus'),
        document.getElementById('filter-near-harbours'),
        document.getElementById('filter-near-military'),
        document.getElementById('filter-near-airports')
      ].filter(control => control !== null).forEach(control => {
        control.addEventListener('input', () => {
          if (control.id === 'show-risk-rings') {
            state.showRiskRings = control.checked;
          } else if (control.id === 'compare-mode') {
            state.compareMode = control.checked;
            document.getElementById('compare-controls').style.display = control.checked ? 'block' : 'none';
          } else if (control.id === 'auto-focus') {
            state.autoFocusEnabled = control.checked;
          }
          render();
          saveStateToURL();
        });
        control.addEventListener('change', () => {
          if (control.id === 'show-risk-rings') {
            state.showRiskRings = control.checked;
          } else if (control.id === 'show-threat-heatmap') {
            state.showThreatHeatmap = control.checked;
          } else if (control.id === 'compare-mode') {
            state.compareMode = control.checked;
            document.getElementById('compare-controls').style.display = control.checked ? 'block' : 'none';
          } else if (control.id === 'auto-focus') {
            state.autoFocusEnabled = control.checked;
          }
          render();
          saveStateToURL();
        });
      });

      document.getElementById('searchBox').addEventListener('input', () => {
        render();
        saveStateToURL();
      });

      // Breaking news alert close button
      document.getElementById('breaking-close').addEventListener('click', () => {
        hideBreakingNewsAlert();
      });

      // Share button functionality
      document.getElementById('btn-share').addEventListener('click', async () => {
        saveStateToURL();
        try {
          await navigator.clipboard.writeText(window.location.href);
          const btn = document.getElementById('btn-share');
          const originalText = btn.innerHTML;
          btn.innerHTML = '✓ Copied';
          setTimeout(() => btn.innerHTML = originalText, 2000);
        } catch (err) {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = window.location.href;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('Link copied to clipboard');
        }
      });

      // Save state on map moves
      map.on('moveend', saveStateToURL);

      // Modal controls
      document.getElementById('closeProvenance').addEventListener('click', hideProvenance);
      document.getElementById('provenanceModal').addEventListener('click', (e) => {
        if (e.target.id === 'provenanceModal') hideProvenance();
      });

      // ESC key to close modal
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') hideProvenance();
      });

      dateLabel.textContent = `Showing last ${dateRange.value} days`;
    }

      setupUI();
      refreshAll();
      setInterval(refreshAll, REFRESH_MS);
    } // End of initializeMap function

    // Initialize map when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeMap);
    } else {
      // DOM is already ready
      initializeMap();
    }
  </script><script>
    // Setup Modern Mobile UX
    function setupMobileUX() {
      const fab = document.getElementById('mobile-fab');
      const bottomSheet = document.getElementById('mobile-bottom-sheet');
      const mobileNav = document.getElementById('mobile-nav');

      // FAB click handler
      if (fab) {
        fab.addEventListener('click', () => {
          bottomSheet.classList.toggle('open');
        });
      }

      // Mobile navigation
      if (mobileNav) {
        const navItems = mobileNav.querySelectorAll('.mobile-nav-item');
        navItems.forEach(item => {
          item.addEventListener('click', (e) => {
            e.preventDefault();

            // Update active state
            navItems.forEach(nav => nav.classList.remove('active'));
            item.classList.add('active');

            // Handle tab switching
            const tab = item.dataset.tab;
            handleMobileTabSwitch(tab);
          });
        });
      }

      // Close bottom sheet on backdrop click
      bottomSheet.addEventListener('click', (e) => {
        if (e.target === bottomSheet) {
          bottomSheet.classList.remove('open');
        }
      });

      // Swipe gestures for bottom sheet
      let startY = 0;
      let currentY = 0;

      bottomSheet.addEventListener('touchstart', (e) => {
        startY = e.touches[0].clientY;
      });

      bottomSheet.addEventListener('touchmove', (e) => {
        currentY = e.touches[0].clientY;
        const diff = currentY - startY;

        if (diff > 50 && bottomSheet.classList.contains('open')) {
          bottomSheet.classList.remove('open');
        }
      });
    }

    function handleMobileTabSwitch(tab) {
      const bottomSheetContent = document.getElementById('bottom-sheet-content');
      const rightPanel = document.getElementById('right');
      const leftPanel = document.getElementById('left');

      switch(tab) {
        case 'incidents':
          if (rightPanel) {
            bottomSheetContent.innerHTML = rightPanel.innerHTML;
            document.getElementById('mobile-bottom-sheet').classList.add('open');

            // Re-attach click handlers for incident cards in bottom sheet
            const incidentCards = bottomSheetContent.querySelectorAll('.incident');
            incidentCards.forEach(card => {
              card.addEventListener('click', (e) => {
                // Skip if clicking on the provenance button
                if (e.target.classList.contains('provenance-btn')) {
                  return;
                }

                // Find the corresponding incident by matching the asset name
                const incidentName = card.querySelector('strong')?.textContent;
                const state = window.droneState || window.state;
                const focusIncident = window.droneFocusIncident || window.focusIncident;

                if (incidentName && state && state.allIncidents) {
                  // Find incident by asset name
                  const incident = state.allIncidents.find(inc =>
                    inc.asset.name === incidentName
                  );
                  if (incident && focusIncident) {
                    focusIncident(incident);
                  }
                }
              });
            });
          }
          break;
        case 'filters':
          if (leftPanel) {
            bottomSheetContent.innerHTML = leftPanel.innerHTML;
            document.getElementById('mobile-bottom-sheet').classList.add('open');
          }
          break;
        case 'stats':
          const statsContent = document.querySelector('.statbar');
          if (statsContent) {
            bottomSheetContent.innerHTML = `
              <div style="padding: var(--space-4);">
                <h2 style="margin-bottom: var(--space-4);">Statistics Overview</h2>
                ${statsContent.outerHTML}
              </div>
            `;
            document.getElementById('mobile-bottom-sheet').classList.add('open');
          }
          break;
        case 'map':
        default:
          document.getElementById('mobile-bottom-sheet').classList.remove('open');
          break;
      }
    }

    // Initialize mobile UX after DOM is loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setupMobileUX);
    } else {
      setupMobileUX();
    }

    // Register Service Worker for PWA functionality
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        // Initialize Operations Center
        initializeOperationsCenter();

        navigator.serviceWorker.register('/sw.js')
          .then(registration => {
            console.log('Service Worker registered:', registration);
            // Request background sync for data updates
            if ('sync' in registration) {
              registration.sync.register('update-incidents');
            }
          })
          .catch(err => console.error('Service Worker registration failed:', err));
      });

      // Listen for service worker messages
      navigator.serviceWorker.addEventListener('message', event => {
        if (event.data.type === 'incidents-updated') {
          console.log('New incident data received from service worker');
          // Optionally reload data without page refresh
          if (window.droneState && window.droneState.data) {
            window.droneState.data = event.data.data;
            render();
          }
        }
      });
    }

    // 🤖 AI-powered news fetching
    async function fetchRealTimeNews() {
      const aiBtn = document.getElementById('ai-fetch-btn');
      if (!AI_CONFIG.OPENROUTER_API_KEY) {
        aiBtn.textContent = '⚠️ No API Key';
        return;
      }

      try {
        aiBtn.textContent = '🔄 Fetching...';
        console.log('🤖 Fetching real-time drone incidents using AI...');

        const prompt = `Search for recent drone incidents in Europe from the last 24 hours. Focus on airport closures, military incidents, critical infrastructure threats. Return JSON array: [{"location":"airport name","lat":latitude,"lon":longitude,"description":"brief description","severity":1-10,"category":"sighting|closure|threat","asset_type":"airport|military"}]`;

        const response = await fetch(AI_CONFIG.OPENROUTER_API_URL, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${AI_CONFIG.OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.origin,
            'X-Title': 'DroneWatch'
          },
          body: JSON.stringify({
            model: AI_CONFIG.FREE_MODELS[0], // Use Grok-4 Fast
            messages: [
              { role: 'system', content: 'You are a drone incident analyst. Return only valid JSON.' },
              { role: 'user', content: prompt }
            ],
            max_tokens: 1000,
            temperature: 0.1
          })
        });

        if (response.ok) {
          const aiData = await response.json();
          const content = aiData.choices[0]?.message?.content;
          console.log('✅ AI Response:', content);

          try {
            const incidents = JSON.parse(content);
            if (Array.isArray(incidents) && incidents.length > 0) {
              console.log(`🎯 Adding ${incidents.length} AI incidents`);

              // Convert to app format and add
              const enhancedIncidents = incidents.map((inc, i) => ({
                id: `ai-${Date.now()}-${i}`,
                first_seen_utc: new Date().toISOString(),
                last_update_utc: new Date().toISOString(),
                asset: { type: inc.asset_type || 'airport', name: inc.location, lat: inc.lat, lon: inc.lon },
                incident: { category: inc.category || 'sighting', status: 'active', narrative: inc.description },
                scores: { severity: inc.severity || 5 },
                tags: ['ai-generated', 'real-time'],
                data_type: 'ai_enhanced'
              }));

              state.data.incidents = [...state.data.incidents, ...enhancedIncidents];
              render();
              renderNewsBriefs(state.data.incidents);
              aiBtn.textContent = `✅ +${incidents.length} AI`;
            } else {
              aiBtn.textContent = '📭 No new data';
            }
          } catch (parseErr) {
            console.warn('Parse error:', parseErr);
            aiBtn.textContent = '⚠️ Parse Error';
          }
        } else {
          aiBtn.textContent = '❌ API Error';
        }
      } catch (err) {
        console.error('AI fetch failed:', err);
        aiBtn.textContent = '❌ Failed';
      }

      setTimeout(() => {
        aiBtn.textContent = '🤖 AI News';
        renderNewsBriefs(state.data.incidents);
      }, 3000);
    }
  </script>
</body>
</html>
